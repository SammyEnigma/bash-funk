#!/usr/bin/env bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
function -block-port() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [BIND_ADDRESS] PORT"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-block-port() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _duration _help _selftest _BIND_ADDRESS _PORT
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [BIND_ADDRESS] PORT"
                echo
                echo "Binds to the given port and thus block other programs from binding to it."
                echo
                echo "Parameters:"
                echo -e "  \033[1mBIND_ADDRESS\033[22m (default: '0.0.0.0')"
                echo "      The local bind address. E.g. 127.0.0.1."
                echo -e "  \033[1mPORT\033[22m (required, integer: 0-65535)"
                echo "      Number of the port to occupy."
                echo
                echo "Options:"
                echo -e "\033[1m-d, --duration SECONDS\033[22m (integer: ?-?)"
                echo "        Duration in seconds to block the port."
                echo "    -----------------------------"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                echo "Examples:"
                echo -e "$ \033[1m$__fn --duration 1  12345\033[22m"
                echo "Binding to 0.0.0.0:12345...
Press [CTRL]+[C] to abort."
                echo -e "$ \033[1m$__fn -d 1  127.0.0.1  12345\033[22m"
                echo "Binding to 127.0.0.1:12345...
Press [CTRL]+[C] to abort."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn --duration 1  12345\033[22m"
                __stdout="$($__fn --duration 1  12345)"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^Binding to 0\.0\.0\.0:12345\.\.\.
Press \[CTRL]\+\[C] to abort\.$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Binding to 0\.0\.0\.0:12345\.\.\.
Press \[CTRL]\+\[C] to abort\.]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn -d 1  127.0.0.1  12345\033[22m"
                __stdout="$($__fn -d 1  127.0.0.1  12345)"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^Binding to 127\.0\.0\.1:12345\.\.\.
Press \[CTRL]\+\[C] to abort\.$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Binding to 127\.0\.0\.1:12345\.\.\.
Press \[CTRL]\+\[C] to abort\.]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn 70000\033[22m"
                __stdout="$($__fn 70000)"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 64 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [64]."; return 64; fi
                __regex="Error: Value '70000' for parameter PORT is too high. Must be <= 65535."
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Error: Value '70000' for parameter PORT is too high. Must be <= 65535.]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --duration|-d)
                _duration="@@##@@"
                __optionWithValue=duration
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    duration)
                        _duration=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_BIND_ADDRESS && ${#__params[@]} > 1 ]]; then
            _BIND_ADDRESS=$__param
            continue
        fi
        if [[ ! $_PORT ]]; then
            _PORT=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_BIND_ADDRESS ]]; then _BIND_ADDRESS="0.0.0.0"; fi
    if [[ $_duration ]]; then
        if [[ $_duration == "@@##@@" ]]; then echo "$__fn: Error: Value SECONDS for option --duration must be specified."; return 64; fi
        if [[ ! "$_duration" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_duration' for option --duration is not a numeric value."; return 64; fi
    fi

    if [[ $_PORT ]]; then
        if [[ ! "$_PORT" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is not a numeric value."; return 64; fi
        if [[ $_PORT -lt 0 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too low. Must be >= 0."; return 64; fi
        if [[ $_PORT -gt 65535 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too high. Must be <= 65535."; return 64; fi
    else
        echo "$__fn: Error: Parameter PORT must be specified."; return 64
    fi

    ######### block-port ######### START

echo "Binding to $_BIND_ADDRESS:$_PORT..."

[[ $_duration ]] && local timeout="Timeout => $_duration," || local timeout="";

perl << EOF
    use IO::Socket;
    \$server = IO::Socket::INET->new(
        LocalAddr => '$_BIND_ADDRESS',
        LocalPort => $_PORT,
        Type => SOCK_STREAM,
        ReuseAddr => 1,
        $timeout
        Listen => 10
    ) or die "Couldn't bind to $_BIND_ADDRESS:$_PORT: \$@\n";
    print("Press [CTRL]+[C] to abort.\n");
    while (\$client = \$server->accept()) { }
    close(\$server);
EOF

    ######### block-port ######### END
}
function __complete-block-port() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --duration -d --help "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}block-port -- ${BASH_FUNK_PREFIX:--}block-port

function -is-port-open() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... HOSTNAME PORT [CONNECT_TIMEOUT_IN_SECONDS]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-is-port-open() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _verbose _HOSTNAME _PORT _CONNECT_TIMEOUT_IN_SECONDS
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... HOSTNAME PORT [CONNECT_TIMEOUT_IN_SECONDS]"
                echo
                echo "Checks if a TCP connection can be established to the given port."
                echo
                echo "Parameters:"
                echo -e "  \033[1mHOSTNAME\033[22m (required)"
                echo "      Target hostname."
                echo -e "  \033[1mPORT\033[22m (required, integer: 0-65535)"
                echo "      Target TCP port."
                echo -e "  \033[1mCONNECT_TIMEOUT_IN_SECONDS\033[22m (default: '5', integer: ?-?)"
                echo "      Number of seconds to try to connect to the given port. Default is 5 seconds."
                echo
                echo "Options:"
                echo -e "\033[1m-v, --verbose\033[22m "
                echo "        Prints additional information during command execution."
                echo "    -----------------------------"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                echo "Examples:"
                echo -e "$ \033[1m$__fn localhost 12345 1\033[22m"
                echo
                echo -e "$ \033[1m$__fn -v localhost 12345 1\033[22m"
                echo "localhost:12345 is not reachable."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn localhost 12345 1\033[22m"
                __stdout="$($__fn localhost 12345 1)"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 1 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [1]."; return 64; fi
                __regex=""
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern []."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn -v localhost 12345 1\033[22m"
                __stdout="$($__fn -v localhost 12345 1)"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 1 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [1]."; return 64; fi
                __regex="localhost:12345 is not reachable."
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [localhost:12345 is not reachable.]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn localhost 70000\033[22m"
                __stdout="$($__fn localhost 70000)"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 64 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [64]."; return 64; fi
                __regex="Error: Value '70000' for parameter PORT is too high. Must be <= 65535."
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Error: Value '70000' for parameter PORT is too high. Must be <= 65535.]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --verbose|-v)
                _verbose=1
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_HOSTNAME ]]; then
            _HOSTNAME=$__param
            continue
        fi
        if [[ ! $_PORT ]]; then
            _PORT=$__param
            continue
        fi
        if [[ ! $_CONNECT_TIMEOUT_IN_SECONDS ]]; then
            _CONNECT_TIMEOUT_IN_SECONDS=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_CONNECT_TIMEOUT_IN_SECONDS ]]; then _CONNECT_TIMEOUT_IN_SECONDS="5"; fi

    if [[ $_HOSTNAME ]]; then
        true
    else
        echo "$__fn: Error: Parameter HOSTNAME must be specified."; return 64
    fi
    if [[ $_PORT ]]; then
        if [[ ! "$_PORT" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is not a numeric value."; return 64; fi
        if [[ $_PORT -lt 0 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too low. Must be >= 0."; return 64; fi
        if [[ $_PORT -gt 65535 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too high. Must be <= 65535."; return 64; fi
    else
        echo "$__fn: Error: Parameter PORT must be specified."; return 64
    fi
    if [[ $_CONNECT_TIMEOUT_IN_SECONDS ]]; then
        if [[ ! "$_CONNECT_TIMEOUT_IN_SECONDS" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_CONNECT_TIMEOUT_IN_SECONDS' for parameter CONNECT_TIMEOUT_IN_SECONDS is not a numeric value."; return 64; fi
    fi

    ######### is-port-open ######### START

if hash nc &>/dev/null; then
    if nc -vz -w $_CONNECT_TIMEOUT_IN_SECONDS $_HOSTNAME $_PORT; then
        portStatus=open
    else
        portStatus=
    fi
else
    local portStatus=$(perl << EOF
        use IO::Socket;
        my \$socket=IO::Socket::INET->new(
            PeerAddr => "$_HOSTNAME",
            PeerPort => $_PORT,
            Timeout => $_CONNECT_TIMEOUT_IN_SECONDS
        );

        if (defined \$socket) {
            sleep 1;
            (defined \$socket->connected ? print("open") : q{});
        }
EOF
    )
fi

if [[ $portStatus == "open" ]]; then
    [[ $_verbose ]] && echo "$_HOSTNAME:$_PORT is open." || true
    return 0
else
    [[ $_verbose ]] && echo "$_HOSTNAME:$_PORT is not reachable." || true
    return 1
fi

    ######### is-port-open ######### END
}
function __complete-is-port-open() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --verbose -v "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}is-port-open -- ${BASH_FUNK_PREFIX:--}is-port-open

function -my-ips() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-my-ips() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]..."
                echo
                echo "Prints the IP v4 addresses of this host excluding 127.0.0.1."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### my-ips ######### START

ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'

    ######### my-ips ######### END
}
function __complete-my-ips() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}my-ips -- ${BASH_FUNK_PREFIX:--}my-ips

function -run-echo-server() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [BIND_ADDRESS] PORT"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-run-echo-server() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _stop_when _disconnect_when _help _selftest _BIND_ADDRESS _PORT
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [BIND_ADDRESS] PORT"
                echo
                echo "Runs a simple single-connection TCP echo server."
                echo
                echo "Requirements:"
                echo "  + Command 'python' must be available."
                echo
                echo "Parameters:"
                echo -e "  \033[1mBIND_ADDRESS\033[22m (default: '0.0.0.0')"
                echo "      The local bind address. E.g. 127.0.0.1."
                echo -e "  \033[1mPORT\033[22m (required, integer: 0-65535)"
                echo "      Number of the TCP port to be used."
                echo
                echo "Options:"
                echo -e "\033[1m    --disconnect_when string\033[22m "
                echo "        String that can be send to the server to disconnect the current connection."
                echo -e "\033[1m    --stop_when string\033[22m "
                echo "        String that can be send to the server to shut it down."
                echo "    -----------------------------"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --stop_when)
                _stop_when="@@##@@"
                __optionWithValue=stop_when
            ;;

            --disconnect_when)
                _disconnect_when="@@##@@"
                __optionWithValue=disconnect_when
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    stop_when)
                        _stop_when=$__arg
                        __optionWithValue=
                      ;;
                    disconnect_when)
                        _disconnect_when=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_BIND_ADDRESS && ${#__params[@]} > 1 ]]; then
            _BIND_ADDRESS=$__param
            continue
        fi
        if [[ ! $_PORT ]]; then
            _PORT=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_BIND_ADDRESS ]]; then _BIND_ADDRESS="0.0.0.0"; fi
    if [[ $_stop_when ]]; then
        if [[ $_stop_when == "@@##@@" ]]; then echo "$__fn: Error: Value string for option --stop_when must be specified."; return 64; fi
    fi
    if [[ $_disconnect_when ]]; then
        if [[ $_disconnect_when == "@@##@@" ]]; then echo "$__fn: Error: Value string for option --disconnect_when must be specified."; return 64; fi
    fi

    if [[ $_PORT ]]; then
        if [[ ! "$_PORT" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is not a numeric value."; return 64; fi
        if [[ $_PORT -lt 0 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too low. Must be >= 0."; return 64; fi
        if [[ $_PORT -gt 65535 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too high. Must be <= 65535."; return 64; fi
    else
        echo "$__fn: Error: Parameter PORT must be specified."; return 64
    fi

    if ! hash "python" &>/dev/null; then echo "$__fn: Error: Required command 'python' not found on this system."; return 64; fi

    ######### run-echo-server ######### START


if [[ ! $_stop_when ]]; then
    local _stop_when=stop
fi

if [[ ! $_disconnect_when ]]; then
    local _disconnect_when=quit
fi

python -c "
import socket, sys

def run():
    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind(('$_BIND_ADDRESS', $_PORT))
    srv.listen(0)

    print_ = sys.stdout.write
    print_('Running TCP echo server on $_BIND_ADDRESS:$_PORT...\\n')

    while 1:
        conn, src_addr = srv.accept()
        print_('[CONNECT] ' + str(src_addr) + '\\n')

        while 1:
            data, src_addr = conn.recvfrom(256)

            if not data:
                continue

            if data == '$_stop_when\r\n':
                print_('[SHUTDOWN] ' + str(src_addr) + '\\n')
                sys.exit(0)

            if data == '$_disconnect_when\r\n':
                print_('[DISCONNECT] ' + str(src_addr) + '\\n')
                conn.shutdown(1)
                conn.close()
                break

            conn.sendall(data)
            print_(data)

try:
    run()
except KeyboardInterrupt:
    pass
"

    ######### run-echo-server ######### END
}
function __complete-run-echo-server() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --stop_when --disconnect_when --help "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}run-echo-server -- ${BASH_FUNK_PREFIX:--}run-echo-server

function -set-proxy() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... PROXY_URL [NO_PROXY]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-set-proxy() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _verbose _PROXY_URL _NO_PROXY
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... PROXY_URL [NO_PROXY]"
                echo
                echo "Sets the proxy environment variables."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPROXY_URL\033[22m (required)"
                echo "      The proxy URL to set."
                echo -e "  \033[1mNO_PROXY\033[22m "
                echo "      Proxy exclusions."
                echo
                echo "Options:"
                echo -e "\033[1m-v, --verbose\033[22m "
                echo "        Prints additional information during command execution."
                echo "    -----------------------------"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --verbose|-v)
                _verbose=1
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PROXY_URL ]]; then
            _PROXY_URL=$__param
            continue
        fi
        if [[ ! $_NO_PROXY ]]; then
            _NO_PROXY=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_PROXY_URL ]]; then
        true
    else
        echo "$__fn: Error: Parameter PROXY_URL must be specified."; return 64
    fi

    ######### set-proxy ######### START

for varname in all_proxy ALL_PROXY ftp_proxy FTP_PROXY http_proxy HTTP_PROXY https_proxy HTTPS_PROXY; do
    [[ $_verbose ]] && echo "Setting $varname=$_PROXY_URL"
    export $varname=$_PROXY_URL
done

# exclude local IPs from proxy
if hash ifconfig &>/dev/null; then
    local my_ips=$(ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*')
else
    local my_ips=::1,127.0.0.1
fi
no_proxy=localhost,${my_ips//$'\n'/,}

# exclude metadata IP if AWS EC2 server
if [[ -f /sys/hypervisor/uuid && $(head -c 3 /sys/hypervisor/uuid) == "ec2" ]]; then
    no_proxy="$no_proxy,169.254.169.254"
fi

export no_proxy="$no_proxy,$_NO_PROXY"
[[ $_verbose ]] && echo "Setting no_proxy=$no_proxy"
[[ $_verbose ]] && echo "Setting NO_PROXY="
export NO_PROXY=$no_proxy

    ######### set-proxy ######### END
}
function __complete-set-proxy() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --verbose -v "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}set-proxy -- ${BASH_FUNK_PREFIX:--}set-proxy

function -ssh-agent-add-key() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... KEY_FILE PASSWORD"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ssh-agent-add-key() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _KEY_FILE _PASSWORD
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... KEY_FILE PASSWORD"
                echo
                echo "Adds the private key to the ssh-agent."
                echo
                echo "Requirements:"
                echo "  + Command 'ssh-add' must be available."
                echo "  + Command 'ssh-agent' must be available."
                echo "  + Command 'expect' must be available."
                echo
                echo "Parameters:"
                echo -e "  \033[1mKEY_FILE\033[22m (required, file)"
                echo "      Path to the key file."
                echo -e "  \033[1mPASSWORD\033[22m (required)"
                echo "      Password to open the key file."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_KEY_FILE ]]; then
            _KEY_FILE=$__param
            continue
        fi
        if [[ ! $_PASSWORD ]]; then
            _PASSWORD=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_KEY_FILE ]]; then
        if [[ ! -e "$_KEY_FILE" ]]; then echo "$__fn: Error: File '$_KEY_FILE' for parameter KEY_FILE does not exist."; return 64; fi
        if [[ -e "$_KEY_FILE" && ! -f "$_KEY_FILE" ]]; then echo "$__fn: Error: Path '$_KEY_FILE' for parameter KEY_FILE is not a file."; return 64; fi
        if [[ ! -r "$_KEY_FILE" ]]; then echo "$__fn: Error: File '$_KEY_FILE' for parameter KEY_FILE is not readable by user '$USER'."; return 64; fi
    else
        echo "$__fn: Error: Parameter KEY_FILE must be specified."; return 64
    fi
    if [[ $_PASSWORD ]]; then
        true
    else
        echo "$__fn: Error: Parameter PASSWORD must be specified."; return 64
    fi

    if ! hash "ssh-add" &>/dev/null; then echo "$__fn: Error: Required command 'ssh-add' not found on this system."; return 64; fi
    if ! hash "ssh-agent" &>/dev/null; then echo "$__fn: Error: Required command 'ssh-agent' not found on this system."; return 64; fi
    if ! hash "expect" &>/dev/null; then echo "$__fn: Error: Required command 'expect' not found on this system."; return 64; fi

    ######### ssh-agent-add-key ######### START

eval $(ssh-agent)

expect << EOF
  spawn ssh-add $_KEY_FILE
  expect "Enter passphrase"
  send "$_PASSWORD\r"
  expect eof
EOF

    ######### ssh-agent-add-key ######### END
}
function __complete-ssh-agent-add-key() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ssh-agent-add-key -- ${BASH_FUNK_PREFIX:--}ssh-agent-add-key

function -ssh-trust-host() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... HOSTNAME [PORT]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ssh-trust-host() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _HOSTNAME _PORT
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... HOSTNAME [PORT]"
                echo
                echo "Adds the public key of the given host to the ~/.ssh/known_hosts file."
                echo
                echo "Requirements:"
                echo "  + Command 'ssh-keyscan' must be available."
                echo
                echo "Parameters:"
                echo -e "  \033[1mHOSTNAME\033[22m (required)"
                echo "      Remote SSH Hostname."
                echo -e "  \033[1mPORT\033[22m (default: '22', integer: 0-65535)"
                echo "      Remote SSH port."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_HOSTNAME ]]; then
            _HOSTNAME=$__param
            continue
        fi
        if [[ ! $_PORT ]]; then
            _PORT=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_PORT ]]; then _PORT="22"; fi

    if [[ $_HOSTNAME ]]; then
        true
    else
        echo "$__fn: Error: Parameter HOSTNAME must be specified."; return 64
    fi
    if [[ $_PORT ]]; then
        if [[ ! "$_PORT" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is not a numeric value."; return 64; fi
        if [[ $_PORT -lt 0 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too low. Must be >= 0."; return 64; fi
        if [[ $_PORT -gt 65535 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too high. Must be <= 65535."; return 64; fi
    fi

    if ! hash "ssh-keyscan" &>/dev/null; then echo "$__fn: Error: Required command 'ssh-keyscan' not found on this system."; return 64; fi

    ######### ssh-trust-host ######### START

touch ~/.ssh/known_hosts
ssh-keyscan -t rsa,dsa -p $_PORT $_HOSTNAME 2>/dev/null | sort -u - ~/.ssh/known_hosts > ~/.ssh/known_hosts.tmp
mv ~/.ssh/known_hosts.tmp ~/.ssh/known_hosts

    ######### ssh-trust-host ######### END
}
function __complete-ssh-trust-host() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ssh-trust-host -- ${BASH_FUNK_PREFIX:--}ssh-trust-host

function -test-network() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-test-network() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]..."
                echo
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### test-network ######### START

${BASH_FUNK_PREFIX:--}block-port --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}is-port-open --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}my-ips --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}run-echo-server --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}set-proxy --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ssh-agent-add-key --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ssh-trust-host --selftest && echo || return 1

    ######### test-network ######### END
}
function __complete-test-network() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-network -- ${BASH_FUNK_PREFIX:--}test-network


function -help-network() {
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}block-port [BIND_ADDRESS] PORT\033[0m  -  Binds to the given port and thus block other programs from binding to it."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}is-port-open HOSTNAME PORT [CONNECT_TIMEOUT_IN_SECONDS]\033[0m  -  Checks if a TCP connection can be established to the given port."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}my-ips\033[0m  -  Prints the IP v4 addresses of this host excluding 127.0.0.1."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}run-echo-server [BIND_ADDRESS] PORT\033[0m  -  Runs a simple single-connection TCP echo server."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}set-proxy PROXY_URL [NO_PROXY]\033[0m  -  Sets the proxy environment variables."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ssh-agent-add-key KEY_FILE PASSWORD\033[0m  -  Adds the private key to the ssh-agent."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ssh-trust-host HOSTNAME [PORT]\033[0m  -  Adds the public key of the given host to the ~/.ssh/known_hosts file."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}test-network\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."

}
__BASH_FUNK_FUNCS+=( block-port is-port-open my-ips run-echo-server set-proxy ssh-agent-add-key ssh-trust-host test-network )
