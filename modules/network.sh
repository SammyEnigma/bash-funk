#!/bin/bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#

function -block-port() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... [BIND_ADDRESS] PORT

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _BIND_ADDRESS _PORT
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... [BIND_ADDRESS] PORT"
                echo 
                echo "Binds to the given port and thus block other programs from binding to it."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mBIND_ADDRESS\033[22m "
                echo "      The local bind address. E.g. 127.0.0.1."
                echo -e "  \033[1mPORT\033[22m (required)"
                echo "      Number of the port to occupy."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \033[1m$fn 70000\033[22m"
                echo "Error: Value '70000' for parameter PORT is too high. Must be <= 65535."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \033[1m$fn 70000\033[22m"
                stdout=$($fn 70000); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1].$hint"; return 1; fi
                regex="^Error: Value '70000' for parameter PORT is too high. Must be <= 65535.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '70000' for parameter PORT is too high. Must be <= 65535.].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_BIND_ADDRESS && ${#params[@]} > 1 ]]; then
            _BIND_ADDRESS=$param
            continue
        fi
        if [[ ! $_PORT ]]; then
            _PORT=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_BIND_ADDRESS ]]; then
        true
    fi
    if [[ $_PORT ]]; then
        if [[ ! "$_PORT" =~ ^-?[0-9]*$ ]]; then echo "$fn: Error: Value '$_PORT' for parameter PORT is not a numeric value.$hint"; return 1; fi
        if [[ $_PORT -lt 0 ]]; then echo "$fn: Error: Value '$_PORT' for parameter PORT is too low. Must be >= 0.$hint"; return 1; fi
        if [[ $_PORT -gt 65535 ]]; then echo "$fn: Error: Value '$_PORT' for parameter PORT is too high. Must be <= 65535.$hint"; return 1; fi
        true
    else
        echo "$fn: Error: Parameter PORT must be specified.$hint"; return 1
    fi
    
    
    ######################################################

if [[ $_BIND_ADDRESS ]]; then
    local localAddr=$_BIND_ADDRESS
    local localPort=$_PORT
else
    local localAddr=0.0.0.0
    local localPort=$_PORT
fi

echo "Binding to $localAddr:$localPort..."

perl << EOF
    use IO::Socket;
    \$server = IO::Socket::INET->new(
        LocalAddr => '$localAddr',
        LocalPort => $localPort,
        Type => SOCK_STREAM,
        ReuseAddr => 1,
        Listen => 10
    ) or die "Couldn't bind to $localAddr:$localPort: \$@\n";
    while (\$client = \$server->accept()) { }
    close(\$server);
EOF

}
function _-block-port() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-block-port -- ${BASH_FUNK_PREFIX:-}-block-port

function -get-ips() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]...

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]..."
                echo 
                echo "Prints the IP v4 addresses of this host excluding 127.0.0.1."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'

}
function _-get-ips() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-get-ips -- ${BASH_FUNK_PREFIX:-}-get-ips

function -is-port-open() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... HOSTNAME PORT [CONNECT_TIMEOUT_IN_SECONDS]

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _verbose _HOSTNAME _PORT _CONNECT_TIMEOUT_IN_SECONDS
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... HOSTNAME PORT [CONNECT_TIMEOUT_IN_SECONDS]"
                echo 
                echo "Checks if a TCP connection can be established to the given port."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mHOSTNAME\033[22m (required)"
                echo "      Target hostname."
                echo -e "  \033[1mPORT\033[22m (required)"
                echo "      Target TCP port."
                echo -e "  \033[1mCONNECT_TIMEOUT_IN_SECONDS\033[22m "
                echo "      Number of seconds to try to connect to the given port. Default is 5 seconds."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo -e "\033[1m-v, --verbose\033[22m "
                echo "        Prints additional information during command execution."
                echo 
                echo "Examples:"
                echo -e "$ \033[1m$fn localhost 12345 1\033[22m"
                echo 
                echo -e "$ \033[1m$fn -v localhost 12345 1\033[22m"
                echo "localhost:12345 is not reachable."
                echo -e "$ \033[1m$fn localhost 70000\033[22m"
                echo "Error: Value '70000' for parameter PORT is too high. Must be <= 65535."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \033[1m$fn localhost 12345 1\033[22m"
                stdout=$($fn localhost 12345 1); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1].$hint"; return 1; fi
                regex="^$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \033[1m$fn -v localhost 12345 1\033[22m"
                stdout=$($fn -v localhost 12345 1); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1].$hint"; return 1; fi
                regex="^localhost:12345 is not reachable.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [localhost:12345 is not reachable.].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \033[1m$fn localhost 70000\033[22m"
                stdout=$($fn localhost 70000); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1].$hint"; return 1; fi
                regex="^Error: Value '70000' for parameter PORT is too high. Must be <= 65535.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '70000' for parameter PORT is too high. Must be <= 65535.].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            --verbose|-v)
                _verbose=true
            ;;
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_HOSTNAME ]]; then
            _HOSTNAME=$param
            continue
        fi
        if [[ ! $_PORT ]]; then
            _PORT=$param
            continue
        fi
        if [[ ! $_CONNECT_TIMEOUT_IN_SECONDS ]]; then
            _CONNECT_TIMEOUT_IN_SECONDS=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_HOSTNAME ]]; then
        true
    else
        echo "$fn: Error: Parameter HOSTNAME must be specified.$hint"; return 1
    fi
    if [[ $_PORT ]]; then
        if [[ ! "$_PORT" =~ ^-?[0-9]*$ ]]; then echo "$fn: Error: Value '$_PORT' for parameter PORT is not a numeric value.$hint"; return 1; fi
        if [[ $_PORT -lt 0 ]]; then echo "$fn: Error: Value '$_PORT' for parameter PORT is too low. Must be >= 0.$hint"; return 1; fi
        if [[ $_PORT -gt 65535 ]]; then echo "$fn: Error: Value '$_PORT' for parameter PORT is too high. Must be <= 65535.$hint"; return 1; fi
        true
    else
        echo "$fn: Error: Parameter PORT must be specified.$hint"; return 1
    fi
    if [[ $_CONNECT_TIMEOUT_IN_SECONDS ]]; then
        if [[ ! "$_CONNECT_TIMEOUT_IN_SECONDS" =~ ^-?[0-9]*$ ]]; then echo "$fn: Error: Value '$_CONNECT_TIMEOUT_IN_SECONDS' for parameter CONNECT_TIMEOUT_IN_SECONDS is not a numeric value.$hint"; return 1; fi
        true
    fi
    
    
    ######################################################

if hash nc &> /dev/null; then
    if nc -vz -w ${_CONNECT_TIMEOUT_IN_SECONDS:-5} $_HOSTNAME $_PORT; then
        portStatus=open
    else
        portStatus=
    fi
else
    local portStatus=$(perl << EOF
        use IO::Socket;
        my \$socket=IO::Socket::INET->new(
            PeerAddr => "$_HOSTNAME",
            PeerPort => $_PORT,
            Timeout => ${_CONNECT_TIMEOUT_IN_SECONDS:-5}
        );

        if (defined \$socket) {
            sleep 1;
            (defined \$socket->connected ? print("open") : q{});
        }
EOF
    )
fi

if [[ $portStatus == "open" ]]; then
    [[ $_verbose ]] && echo "$_HOSTNAME:$_PORT is open." || true
    return 0
else
    [[ $_verbose ]] && echo "$_HOSTNAME:$_PORT is not reachable." || true
    return 1
fi

}
function _-is-port-open() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest --verbose -v "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-is-port-open -- ${BASH_FUNK_PREFIX:-}-is-port-open

function -test-network() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]...

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]..."
                echo 
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

${BASH_FUNK_PREFIX:-}-block-port --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-get-ips --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-is-port-open --selftest && echo || return 1
}
function _-test-network() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-network -- ${BASH_FUNK_PREFIX:-}-test-network

function -help-network() {

    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-block-port [BIND_ADDRESS] PORT\033[0m  -  Binds to the given port and thus block other programs from binding to it."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-get-ips\033[0m  -  Prints the IP v4 addresses of this host excluding 127.0.0.1."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-is-port-open HOSTNAME PORT [CONNECT_TIMEOUT_IN_SECONDS]\033[0m  -  Checks if a TCP connection can be established to the given port."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-test-network\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."

}

