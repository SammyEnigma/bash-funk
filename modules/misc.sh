#!/usr/bin/env bash
#
# Copyright 2015-2021 by Vegard IT GmbH (https://vegardit.com)
# SPDX-License-Identifier: Apache-2.0
#
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH
#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
# documentation: https://github.com/vegardit/bash-funk/tree/master/docs/misc.md
#

function -choose() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... OPTION1 [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-choose() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _assign _default _help _selftest _OPTION=()
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... OPTION1 [OPTION]..."
            echo
            echo "Prompts the user to choose one entry of the given list of options."
            echo
            echo "Parameters:"
            echo -e "  \033[1mOPTION\033[22m (1 or more required)"
            echo "      Allowed options to choose from."
            echo
            echo "Options:"
            echo -e "\033[1m    --assign VARNAME\033[22m"
            echo "        Assigns the selected value to the variable with the given name instead of printing to stdout."
            echo -e "\033[1m    --default OPTION\033[22m"
            echo "        The option to pre-selected."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --assign)
            _assign="@@##@@"
            __optionWithValue=assign
         ;;

         --default)
            _default="@@##@@"
            __optionWithValue=default
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               assign)
                  _assign=$__arg
                  __optionWithValue=
                 ;;
               default)
                  _default=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      _OPTION+=("$__param")
      continue
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_assign ]]; then
      if [[ $_assign == "@@##@@" ]]; then echo "$__fn: Error: Value VARNAME for option --assign must be specified."; return 64; fi
   fi
   if [[ $_default ]]; then
      if [[ $_default == "@@##@@" ]]; then echo "$__fn: Error: Value OPTION for option --default must be specified."; return 64; fi
   fi

   if [[ ${#_OPTION[@]} -lt 1 ]]; then echo "$__fn: Error: For parameter OPTION at least 1 value must be specified. Found: ${#_OPTION[@]}."; return 64; fi

####### choose ####### START
local selectedIndex=0 ESC=$(echo -e "\033") redraw=1 index dialogFD option

# when in a subshell use stderr to render the dialog, so capturing stdout will only contain the selected value
[ -t 1 ] && dialogFD=1 || dialogFD=2

# pre-select if default value was given
if [[ ${_default:-} ]]; then
   for index in "${!_OPTION[@]}"; do
      if [[ $_default == ${_OPTION[$index]} ]]; then
         selectedIndex=$index
      fi
   done
fi

while true; do
   if [[ $redraw ]]; then
      for index in "${!_OPTION[@]}"; do
         option="${_OPTION[$index]}"
         option="${option//$'\n'/\\n}"
         option="${option:0:$(( COLUMNS - 6 ))}"
         if (( index == selectedIndex )); then
            >&$dialogFD echo -e " \033[1m* $option\033[22m"
         else
            >&$dialogFD echo "   $option"
         fi
      done
    fi
    local key= key2= key3= key4=
    read -sN1 key && \
    read -sN1 -t 0.001 key2 && \
    read -sN1 -t 0.001 key3 && \
    read -sN1 -t 0.001 key4 || true
    key=${key}${key2}${key3}${key4}

    case $key in
      ${ESC}*A)
         if (( selectedIndex > 0 )); then
            (( selectedIndex-- ))
            redraw=1
         fi
        ;;
      ${ESC}*B)
         if (( selectedIndex + 1 < ${#_OPTION[@]} )); then
            (( selectedIndex++ ))
            redraw=1
         fi
        ;;
      $ESC)
         echo >&2
         echo "Aborting on user request" >&2
         return 1
        ;;
      *)
         if [[ $key == "" || $key == $'\n' ]]; then
            if [[ $_assign ]]; then
               eval "$_assign=\"${_OPTION[$selectedIndex]//\"/\\\"}\""
            else
               echo "${_OPTION[$selectedIndex]}";
            fi
            return 0
         fi
         redraw=
        ;;
   esac

   if [[ $redraw ]]; then
      ${BASH_FUNK_PREFIX:--}cursor-pos --fd $dialogFD --up "$(( ${#_OPTION[@]} ))"
   fi
done
####### choose ####### END
}
function __complete-choose() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --assign --default --help "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}choose -- ${BASH_FUNK_PREFIX:--}choose

function -env() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-env() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Prints all exported environment variables."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### env ####### START
export -p | cut -d' ' -f3-
####### env ####### END
}
function __complete-env() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}env -- ${BASH_FUNK_PREFIX:--}env

function -help() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-help() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Prints the online help of all bash-funk commands."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### help ####### START
for helpfunc in $(compgen -A function -- ${BASH_FUNK_PREFIX:--}help-); do
   $helpfunc
done | sort
####### help ####### END
}
function __complete-help() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}help -- ${BASH_FUNK_PREFIX:--}help

function -please() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-please() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Re-runs the previously entered command with sudo."
            echo
            echo "Requirements:"
            echo "  + Command 'sudo' must be available."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if ! hash "sudo" &>/dev/null; then echo "$__fn: Error: Required command 'sudo' not found on this system."; return 64; fi

####### please ####### START
local cmd="$(echo $(fc -ln -1))"

if [[ $cmd == sudo* ]]; then
   echo "$__fn: Last command '$cmd' was already executed with sudo."
   return 1
elif [[ $cmd == ${BASH_FUNK_PREFIX:--}please* ]]; then
   echo "$__fn: Executing last command '$cmd' with sudo has no use."
   return 1
fi

[[ $__interactive ]] && echo -e "Executing last command [\033[35m$cmd\033[0m] with sudo..." || true
sudo "$BASH" -c "$cmd"
####### please ####### END
}
function __complete-please() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}please -- ${BASH_FUNK_PREFIX:--}please

function -reload() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-reload() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Reloads bash-funk."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### reload ####### START
if [[ ! ${BASH_FUNK_ROOT} ]]; then
   echo "$__fn: Error: BASH_FUNK_ROOT variable is not defined."
   return 1
fi

if [[ ! -r ${BASH_FUNK_ROOT}/bash-funk.sh ]]; then
   echo "$__fn: Error: File [${BASH_FUNK_ROOT}/bash-funk.sh] is not readable by user [$USER]."
   return 1
fi

source ${BASH_FUNK_ROOT}/bash-funk.sh
####### reload ####### END
}
function __complete-reload() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}reload -- ${BASH_FUNK_PREFIX:--}reload

function -root() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-root() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Starts an interactive shell as root user. Same as 'sudo -i'."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### root ####### START
sudo -i
####### root ####### END
}
function __complete-root() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}root -- ${BASH_FUNK_PREFIX:--}root

function -test-all-misc() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-test-all-misc() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### test-all-misc ####### START
${BASH_FUNK_PREFIX:--}choose --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}env --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}help --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}please --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}reload --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}root --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}tweak-bash --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}update --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}var-exists --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}wait --selftest && echo || return 1
####### test-all-misc ####### END
}
function __complete-test-all-misc() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-all-misc -- ${BASH_FUNK_PREFIX:--}test-all-misc

function -tweak-bash() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-tweak-bash() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _verbose
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Performs some usability configurations of Bash."
            echo
            echo "Options:"
            echo -e "\033[1m-v, --verbose\033[22m"
            echo "        Prints additional information during command execution."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --verbose|-v)
            _verbose=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### tweak-bash ####### START
#
# enable and configure command history
#
set -o history
export HISTFILE=~/.bash_funk_history
export HISTSIZE=10000
export HISTFILESIZE=$HISTSIZE
export HISTCONTROL=ignorespace:ignoredups
export HISTTIMEFORMAT="%F %T "
export HISTIGNORE="&:?:??:clear:exit:pwd"
history -r

#
# Readline productivity tweaks, see https://www.gnu.org/software/bash/manual/html_node/Readline-Init-File-Syntax.html
#
if [[ $- == *i* ]]; then
   bind '"\e[A": history-search-backward' # enable history searching backward using arrow-up
   bind '"\e[B": history-search-forward'  # enable history searching forward using arrow-down
   bind 'set enable-keypad on'            # try to enable the application keypad

   # improve auto-completion
   bind '"\e[6~": menu-complete'           # enable Pg-Up/Down to cycle through completion candidates
   bind '"\e[5~": menu-complete-backward'  # enable Pg-Up/Down to cycle through completion candidates
   bind 'set show-all-if-ambiguous on'     # show words which have more than one possible completion immediately instead of ringing the bell
   bind 'set show-all-if-unmodified on'    # show words which have more than one possible completion without any possible partial completion immediately instead of ringing the bell.
   bind 'set colored-completion-prefix on' 2>/dev/null # highlights the common prefix of the set of possible completions. Requires Bash 4.4 or higher
   bind 'set completion-ignore-case on'    # perform case-insensitive filename matching and completion
fi

# make ls colorful by default except on MacOS where it is not supported
[[ $OSTYPE == "darwin"* ]] || alias -- ls="command ls --color=auto"

#
# aliases
#
alias -- grep="command grep --colour=auto"
alias -- gh='command history | grep'
alias -- l="ll"
alias -- ll="${BASH_FUNK_PREFIX:--}ll"
alias -- ++="${BASH_FUNK_PREFIX:--}cd-down"
alias -- --="${BASH_FUNK_PREFIX:--}cd-hist"
alias -- ..="${BASH_FUNK_PREFIX:--}cd-up"
alias -- ...="command cd ../.."
alias -- -="command cd -"
if hash mc 2>/dev/null && [[ -e /usr/lib/mc/mc-wrapper.sh ]]; then
   # see https://stackoverflow.com/questions/39017391/how-to-make-midnight-commander-exit-to-its-current-directory
   alias mc='. /usr/lib/mc/mc-wrapper.sh'
fi

#
# Bash productivity options, see http://wiki.bash-hackers.org/internals/shell_options
#
local opt opts=(autocd checkwinsize dirspell direxpand extglob globstar histappend)
for opt in ${opts[@]}; do
   if shopt -s $opt &>/dev/null; then
      [[ $_verbose ]] && echo "shopt -s $opt => ENABLED"
   else
      [[ $_verbose ]] && echo "shopt -s $opt => UNSUPPORTED"
   fi
done

#
# cygwin/msys tweaks
#
case "$OSTYPE" in
   cygwin)
      for drive in {a..z}; do
         if [[ -e /cygdrive/${drive} ]]; then
            alias -- "${drive}:"="cd /cygdrive/${drive}"
            alias -- "${drive^^}:"="cd /cygdrive/${drive}"
         fi
      done
      if ! hash sudo &>/dev/null; then
         alias -- sudo="cygstart --action=runas"
      fi
     ;;
   msys)
      for drive in {a..z}; do
         if [[ -e /${drive} ]]; then
            alias -- "${drive}:"="cd /${drive}"
            alias -- "${drive^^}:"="cd /${drive}"
         fi
      done
      if ! hash sudo &>/dev/null; then
         alias -- sudo="cygstart --action=runas"
      fi
     ;;
esac
####### tweak-bash ####### END
}
function __complete-tweak-bash() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --verbose -v "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}tweak-bash -- ${BASH_FUNK_PREFIX:--}tweak-bash

function -update() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-update() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _yes _reload _help _selftest
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Updates bash-funk to the latest code from github (https://github.com/vegardit/bash-funk). All local modifications are overwritten."
            echo
            echo "Options:"
            echo -e "\033[1m-r, --reload\033[22m"
            echo "        Reloads the bash-funk after updating."
            echo -e "\033[1m-y, --yes\033[22m"
            echo "        Answer interactive prompts with 'yes'."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --yes|-y)
            _yes=1
         ;;

         --reload|-r)
            _reload=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### update ####### START
if [[ ! ${BASH_FUNK_ROOT} ]]; then
   echo "$__fn: Error: BASH_FUNK_ROOT variable is not defined."
   return 1
fi

if [[ ! -w ${BASH_FUNK_ROOT} ]]; then
   echo "$__fn: Error: Directory [${BASH_FUNK_ROOT}] is not writeable by user [$USER]."
   return 1
fi

if [[ ! $_yes ]]; then
   read -p "Are you sure you want to update bash-funk located in [${BASH_FUNK_ROOT}]? (y) " -n 1 -r
   echo
   if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo "$__fn: Aborting on user request."
      return 0
   fi
fi

# update via SVN
if [[ -e "${BASH_FUNK_ROOT}/.svn" ]]; then
   svn revert -R "${BASH_FUNK_ROOT}" || return
   svn update "${BASH_FUNK_ROOT}" || return
   [[ $_reload ]] && ${BASH_FUNK_PREFIX:--}reload || true
   return
fi

# update via Git
if [[ -e "${BASH_FUNK_ROOT}/.git" ]]; then
   ( cd "${BASH_FUNK_ROOT}" && git config core.autocrlf false && git fetch && git reset origin/master --hard && git pull ) || return
   [[ $_reload ]] && ${BASH_FUNK_PREFIX:--}reload || true
   return
fi

# update via curl/wget
local get
if hash curl &>/dev/null; then
   get="curl -#L"
else
   if wget --help | grep -- --show-progress &>/dev/null; then
      get="wget -qO- --show-progress"
   else
      get="wget -qO-"
   fi
fi
( cd "${BASH_FUNK_ROOT}" && $get https://github.com/vegardit/bash-funk/tarball/master | tar -xzv --strip-components 1 ) || return
[[ $_reload ]] && ${BASH_FUNK_PREFIX:--}reload || true
return
####### update ####### END
}
function __complete-update() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --yes -y --reload -r --help "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}update -- ${BASH_FUNK_PREFIX:--}update

function -var-exists() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... VARIABLE_NAME\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-var-exists() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _verbose _VARIABLE_NAME
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... VARIABLE_NAME"
            echo
            echo "Determines if the given variable is declared."
            echo
            echo "Parameters:"
            echo -e "  \033[1mVARIABLE_NAME\033[22m (required)"
            echo "      Name of the Bash variable to check."
            echo
            echo "Options:"
            echo -e "\033[1m-v, --verbose\033[22m"
            echo "        Prints additional information during command execution."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn USER\033[22m"
            echo
            echo -e "$ \033[1m$__fn -v USER\033[22m"
            echo "Bash variable 'USER' exists."
            echo -e "$ \033[1m$__fn -v NON_EXISTANT_VARIABLE\033[22m"
            echo "Bash variable 'NON_EXISTANT_VARIABLE' does not exist."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn USER\033[22m"
            __stdout="$($__fn USER)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            if [[ -n "$__stdout" ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required string []."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn -v USER\033[22m"
            __stdout="$($__fn -v USER)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^Bash variable 'USER' exists.$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Bash variable 'USER' exists.]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn -v NON_EXISTANT_VARIABLE\033[22m"
            __stdout="$($__fn -v NON_EXISTANT_VARIABLE)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 1 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [1]."; return 64; fi
            __regex="Bash variable 'NON_EXISTANT_VARIABLE' does not exist."
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Bash variable 'NON_EXISTANT_VARIABLE' does not exist.]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --verbose|-v)
            _verbose=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_VARIABLE_NAME ]]; then
         _VARIABLE_NAME=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_VARIABLE_NAME ]]; then
      true
   else
      echo "$__fn: Error: Parameter VARIABLE_NAME must be specified."; return 64
   fi

####### var-exists ####### START
if ${!_VARIABLE_NAME+false}; then
   [[ $_verbose ]] && echo "Bash variable '$_VARIABLE_NAME' does not exist." || true
   return 1
else
   [[ $_verbose ]] && echo "Bash variable '$_VARIABLE_NAME' exists." || true
   return 0
fi
####### var-exists ####### END
}
function __complete-var-exists() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --verbose -v "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}var-exists -- ${BASH_FUNK_PREFIX:--}var-exists

function -wait() {
   local opts="" opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHt -o pipefail

   __impl$__fn "$@" && rc=0 || rc=$?

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... SECONDS\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-wait() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _SECONDS
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... SECONDS"
            echo
            echo "Waits for the given number of seconds or until the key 's' pressed."
            echo
            echo "Parameters:"
            echo -e "  \033[1mSECONDS\033[22m (required)"
            echo "      Number of seconds to wait."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_SECONDS ]]; then
         _SECONDS=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_SECONDS ]]; then
      true
   else
      echo "$__fn: Error: Parameter SECONDS must be specified."; return 64
   fi

####### wait ####### START
local green="\033[1;32m"
local reset="\033[0m"
local saveCursor="\033[s"
local restoreCursor="\033[u"
local cursor9Right="\033[9C"
local cursor9Left="\033[9D"

echo -ne "Waiting for [$(date +%T --date=@$(($_SECONDS - 3600)))] until $(date +%T --date=@$(($(date +%s) + $_SECONDS))). Press [s] to skip: $cursor9Right"
for (( i = 0; i < _SECONDS; i++ )); do
   if [[ $__interactive ]]; then
      local newLine=
   else
      # adding a \n new line character to the end of the line to make the output parseable by sed which is line oriented
      local newLine="$saveCursor\n$restoreCursor"
   fi
   echo -ne "$cursor9Left$green$(date +%T --date=@$(($_SECONDS - ${i} - 3600))) $reset$newLine"
   local char=
   read -s -n1 -t1 char || :
   [[ $char == "s" ]] && break
done
echo
####### wait ####### END
}
function __complete-wait() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}wait -- ${BASH_FUNK_PREFIX:--}wait


function -help-misc() {
   local p="\033[1m${BASH_FUNK_PREFIX:--}"
   echo -e "${p}choose OPTION1 [OPTION]...\033[0m  -  Prompts the user to choose one entry of the given list of options."
   echo -e "${p}env\033[0m  -  Prints all exported environment variables."
   echo -e "${p}help\033[0m  -  Prints the online help of all bash-funk commands."
   echo -e "${p}please\033[0m  -  Re-runs the previously entered command with sudo."
   echo -e "${p}reload\033[0m  -  Reloads bash-funk."
   echo -e "${p}root\033[0m  -  Starts an interactive shell as root user. Same as 'sudo -i'."
   echo -e "${p}test-all-misc\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."
   echo -e "${p}tweak-bash\033[0m  -  Performs some usability configurations of Bash."
   echo -e "${p}update\033[0m  -  Updates bash-funk to the latest code from github (https://github.com/vegardit/bash-funk). All local modifications are overwritten."
   echo -e "${p}var-exists VARIABLE_NAME\033[0m  -  Determines if the given variable is declared."
   echo -e "${p}wait SECONDS\033[0m  -  Waits for the given number of seconds or until the key 's' pressed."
}
__BASH_FUNK_FUNCS+=( choose env help please reload root test-all-misc tweak-bash update var-exists wait )

function -timeout() {
   if [[ $# < 2 || ${1:-} == "--help" ]]; then
      echo "Usage: ${FUNCNAME[0]} TIMEOUT COMMAND [ARG]..."
      echo "Executes the COMMAND and aborts if it does not finish within the given TIMEOUT in seconds."
      [[ ${1:-} == "--help" ]] && return 0 || return 1
   fi
   if hash timeout 2>/dev/null; then
      timeout "$@"
   elif hash gtimeout 2>/dev/null; then
      # MacOS: https://stackoverflow.com/a/21118126/5116073
      gtimeout "$@"
   else
      # see: http://mywiki.wooledge.org/BashFAQ/068
      perl -e 'alarm shift; exec @ARGV' "$@"
   fi
}
