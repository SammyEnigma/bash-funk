# Bash-Funk "filesystem" module

[//]: # (THIS FILE IS GENERATED BY BASH-FUNK GENERATOR)

The following statements are automatically executed when this module loads:

```bash
alias ll="${BASH_FUNK_PREFIX:-}-ll"
```

The following commands are available when this module is loaded:

1. [-abspath](#-abspath)
1. [-count-words](#-count-words)
1. [-du](#-du)
1. [-extract](#-extract)
1. [-findfiles](#-findfiles)
1. [-ll](#-ll)
1. [-mkcd](#-mkcd)
1. [-modified](#-modified)
1. [-owner](#-owner)
1. [-realpath](#-realpath)
1. [-sudo-append](#-sudo-append)
1. [-sudo-write](#-sudo-write)
1. [-test-filesystem](#-test-filesystem)
1. [-up](#-up)

## <a name="-abspath"></a>-abspath

```
Usage: -abspath [OPTION]... [PATH]

Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist.

Parameters:
  PATH 
      The path to normalize.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
```

*Implementation:*
```bash

# use realpath if available
if hash realpath &> /dev/null; then
    realpath -m ${_PATH:-.}

# use python as last resort
else
    python -c "import os
print os.path.abspath('${_PATH:-.}')"
fi
```


## <a name="-count-words"></a>-count-words

```
Usage: -count-words [OPTION]... FILE WORD1 [WORD]...

Counts the number of occurences of the word(s) in the given file.

Parameters:
  FILE (required)
      The file to analyze.
  WORD (1 or more required)
      The word to count.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
-s, --sort MODE (one of: [count,word])
        Specifies how to sort the output.
```

*Implementation:*
```bash
if [[ ! -e "$_FILE" ]]; then
    echo "Error: File [$_FILE] does not exist."
    return 1
fi

if [[ ! -r "$_FILE" ]]; then
    echo "Error: File [$_FILE] is not readable by user '$USER'."
    return 1
fi

if [[ ! -f "$_FILE" ]]; then
    echo "Error: Path [$_FILE] does not point to a file."
    return 1
fi

local sedCmds grepCmds
for word in "${_WORD[@]}"; do
    sedCmds="s/$word/\n$word\n/g; $sedCmds"
    grepCmds="$grepCmds -e $word"
done

if [[ $_sort_value == "count" ]]; then
    sed "$sedCmds" "$_FILE" | grep $grepCmds | sort | uniq -c | sort -r
else
    sed "$sedCmds" "$_FILE" | grep $grepCmds | sort | uniq -c
fi
```


## <a name="-du"></a>-du

```
Usage: -du [OPTION]...  [PATH]...

Prints disk usage information.

Parameters:
  PATH (0 or more)
      The path to check.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
```

*Implementation:*
```bash
du -s -h ${_PATH[@]}
```


## <a name="-extract"></a>-extract

```
Usage: -extract [OPTION]... FILE

Extracts the given archive using the compatible extractor.

Parameters:
  FILE (required)
      The archive to extract.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
```

*Implementation:*
```bash
if [[ ! -e "$_FILE" ]]; then
    echo "Error: File [$_FILE] does not exist."
    return 1
fi

if [[ ! -r "$_FILE" ]]; then
    echo "Error: File [$_FILE] is not readable by user '$USER'."
    return 1
fi

if [[ ! -f "$_FILE" ]]; then
    echo "Error: Path [$_FILE] does not point to a file."
    return 1
fi

case "$_FILE" in
    *.bz2)            bunzip2    "$_FILE" ;;
    *.gz)             gunzip     "$_FILE" ;;
    *.rar)            unrar x    "$_FILE" ;;
    *.tar)            tar xvf    "$_FILE" ;;
    *.tbz2|*.tar.bz2) tar xvjf   "$_FILE" ;;
    *.tgz|*.tar.gz)   tar xvzf   "$_FILE" ;;
    *.zip)            unzip      "$_FILE" ;;
    *.Z)              uncompress "$_FILE" ;;
    *.7z)             7z x       "$_FILE" ;;
    *) echo "Error: Unsupported archive format '$_FILE'"; return 1 ;;
esac
```


## <a name="-findfiles"></a>-findfiles

```
Usage: -findfiles [OPTION]... [START_PATH] SEARCH_STRING

Recursively finds all files containing the given string and displays their path.

Parameters:
  START_PATH 
      The path where to search.
  SEARCH_STRING (required)
      The string to search.

Options:
    --help 
        Prints this help.
-l, --lines 
        Show matching lines of the files that contain the given string.
    --maxdepth levels (integer: ?-?)
        The maximum number of levels to descend into the directory tree below the starting-point.
    --mindepth levels (integer: ?-?)
        The level of directory tree below the starting-point where to start the search.
    --name pattern 
        Name pattern.
    --selftest 
        Performs a self-test.
-u, --unpack 
        Unpack supported archives (.zip, .jar, .war, .ear).
-v, --verbose 
        Prints additional information during command execution.
```

*Implementation:*
```bash

local _START_PATH=${_START_PATH:-.}

if [[ ! -e "$_START_PATH" ]]; then
    echo "Error: Path [$_START_PATH] does not exist."
    return 1
fi

if [[ ! -r "$_START_PATH" ]]; then
    echo "Error: Path [$_START_PATH] is not readable by user '$USER'."
    return 1
fi

if [[ $_lines ]]; then
    local grepCmd="grep -n"
else
    local grepCmd="grep -l"
fi

local findOpts="-type f"
if [[ $_name ]]; then
    findOpts="$findOpts -name $_name_value"
fi
if [[ $_maxdepth ]]; then
    findOpts="$findOpts -maxdepth $_maxdepth_value"
fi
if [[ $_mindepth ]]; then
    findOpts="$findOpts -mindepth $_mindepth_value"
fi

# turn off verbose if part of pipe or subshell
[[ $_in_pipe || $_in_subshell ]] && _verbose=

if [[ $_verbose ]]; then
    if hash tput &>/dev/null; then
        cols=$(tput cols)
    else
        cols=$(stty size| cut -d' ' -f 2)
    fi

    find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
        local message="Scanning $file ..."

        echo -en "\033[s${message:0:$cols}"
        if [[ $_unpack && ( $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ) ]]; then
            if unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
                echo -e "\033[u\033[K$file" || echo -e "$file"
            else
                echo -en "\033[u\033[K"
            fi
        else
            if LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
                echo -e "\033[u\033[K$file" || echo -e "$file"
            else
                echo -en "\033[u\033[K"
            fi
        fi
    done

else

    if [[ $_unpack ]]; then

        find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
            if [[ $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ]]; then
                unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null || true
            else
                LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
            fi
        done

    else

        # to avoid "xargs: environment is too large for exec" on cygwin
        local xargsWorks=1
        if [[ $OSTYPE == cygwin ]]; then
            if ! echo whoami | xargs &> /dev/null; then
                local xargsWorks=
            fi
        fi

        if [[ $xargsWorks ]]; then
            find "$_START_PATH" $findOpts -print0 | LC_ALL=C xargs -r -0 -P2 $grepCmd "$_SEARCH_STRING" 2>/dev/null
        else
            find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
                LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
            done
        fi
    fi
fi
```


## <a name="-ll"></a>-ll

```
Usage: -ll [OPTION]...  [PATH]...

Alternative version of 'ls -lt' hat prints directories and symbolic links to directories before files.

Parameters:
  PATH (0 or more)
      The path to list.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
```

*Implementation:*
```bash

if ls --help | grep -- --group-directories-first >/dev/null; then
    command ls -lAph -I lost+found --color=always --group-directories-first ${_PATH[@]}   
else
    command ls -lAph -I lost+found --color=always ${_PATH[@]} | awk '
        BEGIN { dirs = ""; files = "" }
        /^total/ { total = $0 }                 # capture total line
        /^d/ { dirs = dirs "\n" $0 };           # capture directories
        /^l.*[/]$/ { dirs = dirs "\n" $0 };     # capture symlinks to directories
        /^-/ { files = files "\n" $0 };         # capture files
        /^l.*[^/]$/ { files = files "\n" $0 };  # capture symlinks to files
        END { print total dirs files }'
fi
```


## <a name="-mkcd"></a>-mkcd

```
Usage: -mkcd [OPTION]... PATH

Creates a directory and changes into it.

Parameters:
  PATH (required)
      The path to create.

Options:
    --help 
        Prints this help.
-m, --mode MODE (pattern: "[0-7]{3}")
        The file mode for the new directory.
-p, --parents 
        Automatically create missing parent directories.
    --selftest 
        Performs a self-test.
-v, --verbose 
        Prints additional information during command execution.
```

*Implementation:*
```bash
local mkdirOpts

[[ $_mode    ]] && mkdirOpts="$mkdirOpts -m $_mode_value" || true
[[ $_parents ]] && mkdirOpts="$mkdirOpts -p" || true
[[ $_verbose ]] && mkdirOpts="$mkdirOpts -v" || true

mkdir "$_PATH" && cd "$_PATH"
```


## <a name="-modified"></a>-modified

```
Usage: -modified [OPTION]... [PATH]

Prints the modification timestamp of the given file or directory.

Parameters:
  PATH 
      The file or directory to check.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
```

*Implementation:*
```bash

local _PATH=${_PATH:-.}

if [[ ! -e "$_PATH" ]]; then
    echo "Error: Path [$_PATH] does not exist."
    return 1
fi

if [[ ! -r "$_PATH" ]]; then
    echo "Error: Path [$_PATH] is not readable by user '$USER'."
    return 1
fi

# use stat if available
if hash stat &> /dev/null; then
    echo $(stat -c %y "$_PATH"})

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use File::stat;
print stat("$_PATH")->mtime, "\n"
EOF

# use python as last resort
else
    python -c "import os, pwd
print int(os.path.getmtime('$_PATH'))"
fi
```


## <a name="-owner"></a>-owner

```
Usage: -owner [OPTION]... [PATH]

Prints the owner of the given file or directory.

Parameters:
  PATH 
      The file or directory to check.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
```

*Implementation:*
```bash

local _PATH=${_PATH:-.}

if [[ ! -e "$_PATH" ]]; then
    echo "Error: Path [$_PATH] does not exist."
    return 1
fi

if [[ ! -r "$_PATH" ]]; then
    echo "Error: Path [$_PATH] is not readable by user '$USER'."
    return 1
fi

# use stat if available
if hash stat &> /dev/null; then
    echo $(stat -c %U "$_PATH")

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use File::stat;
print getpwuid(stat("$_PATH")->uid), "\n"
EOF

# use python as last resort
else
    python -c "import os, pwd
print pwd.getpwuid(os.stat('$_PATH').st_uid).pw_name"
fi
```


## <a name="-realpath"></a>-realpath

```
Usage: -realpath [OPTION]... [PATH]

Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist.

Parameters:
  PATH 
      The path to normalize.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
```

*Implementation:*
```bash

# use readlink if available
if hash readlink &> /dev/null; then
    readlink -m "${_PATH:-.}"

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use Cwd 'abs_path';
print abs_path('${_PATH:-.}'), "\n"
EOF

# use python as last resort
else
    python -c "import os
print os.path.realpath('${_PATH:-.}')"
fi
```


## <a name="-sudo-append"></a>-sudo-append

```
Usage: -sudo-append [OPTION]... FILE_PATH CONTENT

Creates a file with the given content.

Requirements:
  + Sudo 'tee --append' is required.

Parameters:
  FILE_PATH (required)
      The path to the file to write.
  CONTENT (required)
      The content to append to the file.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.

Examples:
$ -sudo-append /tmp/testfile.cfg 'foo=bar'
Appending to \[/tmp/testfile.cfg\]...
```

*Implementation:*
```bash
echo "Appending to [$_FILE_PATH]..."
echo "$_CONTENT" | sudo tee --append "$_FILE_PATH" > /dev/null
```


## <a name="-sudo-write"></a>-sudo-write

```
Usage: -sudo-write [OPTION]... FILE_PATH OWNER CONTENT

Creates a file with the given content.

Requirements:
  + Sudo 'sh -c' is required.
  + Sudo 'sh chown' is required.

Parameters:
  FILE_PATH (required)
      The path to the file to write.
  OWNER (required)
      The owner and group to set.
  CONTENT (required)
      The content to write.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.

Examples:
$ -sudo-write /tmp/testfile.cfg $USER:$USER 'foo=bar'
Writing \[/tmp/testfile.cfg\]...
```

*Implementation:*
```bash
echo "Writing [$_FILE_PATH]..."
sudo sh -c "echo '$_CONTENT' > $_FILE_PATH" && sudo chown $_OWNER "$_FILE_PATH"
```


## <a name="-test-filesystem"></a>-test-filesystem

```
Usage: -test-filesystem [OPTION]...

Performs a selftest of all functions of this module by executing each function with option '--selftest'.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
```

*Implementation:*
```bash
-abspath --selftest && echo || return 1
-count-words --selftest && echo || return 1
-du --selftest && echo || return 1
-extract --selftest && echo || return 1
-findfiles --selftest && echo || return 1
-ll --selftest && echo || return 1
-mkcd --selftest && echo || return 1
-modified --selftest && echo || return 1
-owner --selftest && echo || return 1
-realpath --selftest && echo || return 1
-sudo-append --selftest && echo || return 1
-sudo-write --selftest && echo || return 1
-up --selftest && echo || return 1
```


## <a name="-up"></a>-up

```
Usage: -up [OPTION]... [LEVEL_OR_NAME]

Navigates the given levels up in the directory tree.

Parameters:
  LEVEL_OR_NAME 
      The level to navigate up in the directory structure. Numeric value or the name of the directory to go back to.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
```

*Implementation:*
```bash
if [[ ! $_LEVEL_OR_NAME ]]; then 
    cd ..
    return 0
fi

if [[ $_LEVEL_OR_NAME =~ ^[0-9]+$ ]]; then
    local cdArgs
    for (( i = 0; i < _LEVEL_OR_NAME; i++ )); do
        cdArgs="../$cdArgs"
    done
    cd $cdArgs
else
    local path=$(pwd)
    cd "${path%${_LEVEL_OR_NAME}*}${_LEVEL_OR_NAME}"
fi
```


## <a name="license"></a>License

Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

