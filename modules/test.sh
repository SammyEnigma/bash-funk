#!/bin/bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
    
function -test-fn-flags() {

    local arg optionWithValue params=() _myflag _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Test function with custom flags."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m-m, --myflag\e[22m "
                echo "        My flag."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                echo "myflag was not specified"
                echo -e "$ \e[1m${FUNCNAME[0]} --myflag\e[22m"
                echo "myflag was specified"
                echo -e "$ \e[1m${FUNCNAME[0]} -m\e[22m"
                echo "myflag was specified"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                stdout=$(${FUNCNAME[0]} ); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^myflag was not specified$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [myflag was not specified]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --myflag\e[22m"
                stdout=$(${FUNCNAME[0]} --myflag); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^myflag was specified$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [myflag was specified]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} -m\e[22m"
                stdout=$(${FUNCNAME[0]} -m); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^myflag was specified$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [myflag was specified]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
            --myflag|-m)
                _myflag=true
            ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

[[ $_myflag ]] && echo "myflag was specified" || echo "myflag was not specified"

}
function _-test-fn-flags() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --myflag -m --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-fn-flags -- ${BASH_FUNK_PREFIX:-}-test-fn-flags
    
function -test-fn-multi-value-options() {

    local arg optionWithValue params=() _aa _aa_value _bb _bb_value _cc _cc_value _dd _dd_value _ee _ee_value _ff _ff_value _gg _gg_value _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Test function with multi value options."
                echo 
                echo "Options:"
                echo -e "\e[1m-a, --aa [...]\e[22m "
                echo "        Option a."
                echo -e "\e[1m-b, --bb v1[,v2..2]\e[22m "
                echo "        Option b."
                echo -e "\e[1m-c, --cc [...]\e[22m "
                echo "        Option c."
                echo -e "\e[1m-d, --dd [...]\e[22m "
                echo "        Option d."
                echo -e "\e[1m-e, --ee [...]\e[22m "
                echo "        Option e."
                echo -e "\e[1m-f, --ff [...]\e[22m "
                echo "        Option f."
                echo -e "\e[1m-g, --gg [...]\e[22m "
                echo "        Option g."
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                echo "aa:= bb:= cc:= dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --aa\e[22m"
                echo "aa:true= bb:= cc:= dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --aa foo\e[22m"
                echo "aa:true=foo bb:= cc:= dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --aa foo,bar\e[22m"
                echo "aa:true=foo bar bb:= cc:= dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --bb\e[22m"
                echo -e "Error: For option --bb a list with at least 1 value\(s\) must be specified. Found: 0."
                echo -e "$ \e[1m${FUNCNAME[0]} --bb foo,bar\e[22m"
                echo "aa:= bb:true=foo bar cc:= dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --bb foo,bar,fb\e[22m"
                echo "Error: For option --bb a list with no more than 2 values must be specified. Found: 3."
                echo -e "$ \e[1m${FUNCNAME[0]} --cc 123,45\e[22m"
                echo "aa:= bb:= cc:true=123 45 dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --cc 123,abc\e[22m"
                echo "Error: Value 'abc' for option --cc is not a numeric value."
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 1,3\e[22m"
                echo "aa:= bb:= cc:= dd:true=1 3 ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 0,3\e[22m"
                echo "Error: Value '0' for option --dd is too low. Must be >= 1."
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 3,6\e[22m"
                echo "Error: Value '6' for option --dd is too high. Must be <= 5."
                echo -e "$ \e[1m${FUNCNAME[0]} --ee A,B\e[22m"
                echo "aa:= bb:= cc:= dd:= ee:true=A B ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --ee A,F\e[22m"
                echo -e "Error: Value 'F' for option --ee is not one of the allowed values \[A,B,C\]."
                echo -e "$ \e[1m${FUNCNAME[0]} --ff foo,bar\e[22m"
                echo "aa:= bb:= cc:= dd:= ee:= ff:true=foo bar gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --ff foo,123\e[22m"
                echo -e "Error: Value '123' for option --ff does not match required pattern '\[a-z\]\+'."
                echo -e "$ \e[1m${FUNCNAME[0]} --gg 123\e[22m"
                echo "Error: Value '123' for option --gg must only contain characters a-z."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                stdout=$(${FUNCNAME[0]} ); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:= cc:= dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:= cc:= dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --aa\e[22m"
                stdout=$(${FUNCNAME[0]} --aa); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:true= bb:= cc:= dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:true= bb:= cc:= dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --aa foo\e[22m"
                stdout=$(${FUNCNAME[0]} --aa foo); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:true=foo bb:= cc:= dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:true=foo bb:= cc:= dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --aa foo,bar\e[22m"
                stdout=$(${FUNCNAME[0]} --aa foo,bar); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:true=foo bar bb:= cc:= dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:true=foo bar bb:= cc:= dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --bb\e[22m"
                stdout=$(${FUNCNAME[0]} --bb); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For option --bb a list with at least 1 value\(s\) must be specified. Found: 0.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For option --bb a list with at least 1 value\(s\) must be specified. Found: 0.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --bb foo,bar\e[22m"
                stdout=$(${FUNCNAME[0]} --bb foo,bar); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:true=foo bar cc:= dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:true=foo bar cc:= dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --bb foo,bar,fb\e[22m"
                stdout=$(${FUNCNAME[0]} --bb foo,bar,fb); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For option --bb a list with no more than 2 values must be specified. Found: 3.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For option --bb a list with no more than 2 values must be specified. Found: 3.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --cc 123,45\e[22m"
                stdout=$(${FUNCNAME[0]} --cc 123,45); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:= cc:true=123 45 dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:= cc:true=123 45 dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --cc 123,abc\e[22m"
                stdout=$(${FUNCNAME[0]} --cc 123,abc); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'abc' for option --cc is not a numeric value.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'abc' for option --cc is not a numeric value.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 1,3\e[22m"
                stdout=$(${FUNCNAME[0]} --dd 1,3); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:= cc:= dd:true=1 3 ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:= cc:= dd:true=1 3 ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 0,3\e[22m"
                stdout=$(${FUNCNAME[0]} --dd 0,3); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '0' for option --dd is too low. Must be >= 1.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '0' for option --dd is too low. Must be >= 1.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 3,6\e[22m"
                stdout=$(${FUNCNAME[0]} --dd 3,6); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '6' for option --dd is too high. Must be <= 5.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '6' for option --dd is too high. Must be <= 5.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --ee A,B\e[22m"
                stdout=$(${FUNCNAME[0]} --ee A,B); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:= cc:= dd:= ee:true=A B ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:= cc:= dd:= ee:true=A B ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --ee A,F\e[22m"
                stdout=$(${FUNCNAME[0]} --ee A,F); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'F' for option --ee is not one of the allowed values \[A,B,C\].$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'F' for option --ee is not one of the allowed values \[A,B,C\].]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --ff foo,bar\e[22m"
                stdout=$(${FUNCNAME[0]} --ff foo,bar); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:= cc:= dd:= ee:= ff:true=foo bar gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:= cc:= dd:= ee:= ff:true=foo bar gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --ff foo,123\e[22m"
                stdout=$(${FUNCNAME[0]} --ff foo,123); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '123' for option --ff does not match required pattern '\[a-z\]\+'.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '123' for option --ff does not match required pattern '\[a-z\]\+'.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --gg 123\e[22m"
                stdout=$(${FUNCNAME[0]} --gg 123); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '123' for option --gg must only contain characters a-z.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '123' for option --gg must only contain characters a-z.]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
            --aa|-a)
                _aa=true
                _aa_value=()
                optionWithValue=--aa
            ;;
    
            --bb|-b)
                _bb=true
                _bb_value=()
                optionWithValue=--bb
            ;;
    
            --cc|-c)
                _cc=true
                _cc_value=()
                optionWithValue=--cc
            ;;
    
            --dd|-d)
                _dd=true
                _dd_value=()
                optionWithValue=--dd
            ;;
    
            --ee|-e)
                _ee=true
                _ee_value=()
                optionWithValue=--ee
            ;;
    
            --ff|-f)
                _ff=true
                _ff_value=()
                optionWithValue=--ff
            ;;
    
            --gg|-g)
                _gg=true
                _gg_value=()
                optionWithValue=--gg
            ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    --aa)
                        _aa_value=(${arg//,/ })
                        optionWithValue=
                      ;;
                    --bb)
                        _bb_value=(${arg//,/ })
                        optionWithValue=
                      ;;
                    --cc)
                        _cc_value=(${arg//,/ })
                        optionWithValue=
                      ;;
                    --dd)
                        _dd_value=(${arg//,/ })
                        optionWithValue=
                      ;;
                    --ee)
                        _ee_value=(${arg//,/ })
                        optionWithValue=
                      ;;
                    --ff)
                        _ff_value=(${arg//,/ })
                        optionWithValue=
                      ;;
                    --gg)
                        _gg_value=(${arg//,/ })
                        optionWithValue=
                      ;;
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    if [[ _aa ]]; then
        true
    fi
    if [[ _bb ]]; then
        if [[ ${#_bb_value[@]} -lt 1 ]]; then echo "Error: For option --bb a list with at least 1 value(s) must be specified. Found: ${#_bb_value[@]}."; return 1; fi
        if [[ ${#_bb_value[@]} -gt 2 ]]; then echo "Error: For option --bb a list with no more than 2 values must be specified. Found: ${#_bb_value[@]}."; return 1; fi
        true
    fi
    if [[ _cc ]]; then
        local param
        for param in ${_cc_value[@]}; do
            if [[ ! "$param" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$param' for option --cc is not a numeric value."; return 1; fi
        done
        unset param
        true
    fi
    if [[ _dd ]]; then
        local param
        for param in ${_dd_value[@]}; do
            if [[ ! "$param" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$param' for option --dd is not a numeric value."; return 1; fi
            if [[ $param -lt 1 ]]; then echo "Error: Value '$param' for option --dd is too low. Must be >= 1."; return 1; fi
            if [[ $param -gt 5 ]]; then echo "Error: Value '$param' for option --dd is too high. Must be <= 5."; return 1; fi
        done
        unset param
        true
    fi
    if [[ _ee ]]; then
        declare -A allowed=([A]=1 [B]=1 [C]=1)
        local param
        for param in ${_ee_value[@]}; do
            if [[ ! ${allowed[$param]} ]]; then echo "Error: Value '$param' for option --ee is not one of the allowed values [A,B,C]."; return 1; fi
        done
        unset param allowed
        true
    fi
    if [[ _ff ]]; then
        local regex="^[a-z]+$"
        local param
        for param in ${_ff_value[@]}; do
            if [[ ! "$param" =~ $regex ]]; then echo "Error: Value '$param' for option --ff does not match required pattern '[a-z]+'."; return 1; fi
        done
        unset param regex
        true
    fi
    if [[ _gg ]]; then
        local regex="^[a-z]+$"
        local param
        for param in ${_gg_value[@]}; do
            if [[ ! "$param" =~ $regex ]]; then echo "Error: Value '$param' for option --gg must only contain characters a-z."; return 1; fi
        done
        unset param regex
        true
    fi
    
    
    
    ######################################################

echo "aa:$_aa=${_aa_value[@]} bb:$_bb=${_bb_value[@]} cc:$_cc=${_cc_value[@]} dd:$_dd=${_dd_value[@]} ee:$_ee=${_ee_value[@]} ff:$_ff=${_ff_value[@]} gg:$_gg=${_gg_value[@]}"

}
function _-test-fn-multi-value-options() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --aa -a --bb -b --cc -c --dd -d --ee -e --ff -f --gg -g --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-fn-multi-value-options -- ${BASH_FUNK_PREFIX:-}-test-fn-multi-value-options
    
function -test-fn-multi-value-parameters() {

    local arg optionWithValue params=() _help _selftest _AA=() _BB=() _CC=() _DD=() _EE=() _FF=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... AA1 AA2 BB1 BB2 CC1 CC2 DD1 DD2 EE1 EE2 [FF]..."
                echo 
                echo "Test function with single value parameters."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mAA\e[22m (2 to 2required)"
                echo "      Param AA."
                echo -e "  \e[1mBB\e[22m (2 to 2required)"
                echo "      Param BB."
                echo -e "  \e[1mCC\e[22m (2 to 2required)"
                echo "      Param CC."
                echo -e "  \e[1mDD\e[22m (2 to 2required)"
                echo "      Param DD."
                echo -e "  \e[1mEE\e[22m (2 to 2required)"
                echo "      Param EE."
                echo -e "  \e[1mFF\e[22m (0 or more)"
                echo "      Param FF."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                echo "Error: For parameter AA exactly 2 values must be specified. Found: 0."
                echo -e "$ \e[1m${FUNCNAME[0]} aa\e[22m"
                echo "Error: For parameter AA exactly 2 values must be specified. Found: 1."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa\e[22m"
                echo "Error: For parameter BB exactly 2 values must be specified. Found: 0."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12\e[22m"
                echo "Error: For parameter BB exactly 2 values must be specified. Found: 1."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 bb\e[22m"
                echo "Error: Value 'bb' for parameter BB is not a numeric value."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34\e[22m"
                echo "Error: For parameter CC exactly 2 values must be specified. Found: 0."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 0 3\e[22m"
                echo "Error: Value '0' for parameter CC is too low. Must be >= 1."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 6\e[22m"
                echo "Error: Value '6' for parameter CC is too high. Must be <= 5."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5\e[22m"
                echo "Error: For parameter DD exactly 2 values must be specified. Found: 0."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A G\e[22m"
                echo -e "Error: Value 'G' for parameter DD is not one of the allowed values \[A,B,C\]."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A B\e[22m"
                echo "Error: For parameter EE exactly 2 values must be specified. Found: 0."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A B foo 123\e[22m"
                echo -e "Error: Value '123' for parameter EE does not match required pattern '\[a-z\]\+'."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A B foo bar\e[22m"
                echo "AA:aa aa BB:12 34 CC:1 5 DD:A B EE:foo bar FF:"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A B foo bar 123\e[22m"
                echo "Error: Value '123' for parameter FF must only contain characters a-z."
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A B foo bar a b c d e f\e[22m"
                echo "AA:aa aa BB:12 34 CC:1 5 DD:A B EE:foo bar FF:a b c d e f"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                stdout=$(${FUNCNAME[0]} ); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For parameter AA exactly 2 values must be specified. Found: 0.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For parameter AA exactly 2 values must be specified. Found: 0.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa\e[22m"
                stdout=$(${FUNCNAME[0]} aa); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For parameter AA exactly 2 values must be specified. Found: 1.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For parameter AA exactly 2 values must be specified. Found: 1.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For parameter BB exactly 2 values must be specified. Found: 0.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For parameter BB exactly 2 values must be specified. Found: 0.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For parameter BB exactly 2 values must be specified. Found: 1.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For parameter BB exactly 2 values must be specified. Found: 1.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 bb\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 bb); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'bb' for parameter BB is not a numeric value.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'bb' for parameter BB is not a numeric value.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 34); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For parameter CC exactly 2 values must be specified. Found: 0.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For parameter CC exactly 2 values must be specified. Found: 0.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 0 3\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 34 0 3); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '0' for parameter CC is too low. Must be >= 1.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '0' for parameter CC is too low. Must be >= 1.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 6\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 34 1 6); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '6' for parameter CC is too high. Must be <= 5.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '6' for parameter CC is too high. Must be <= 5.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 34 1 5); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For parameter DD exactly 2 values must be specified. Found: 0.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For parameter DD exactly 2 values must be specified. Found: 0.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A G\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 34 1 5 A G); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'G' for parameter DD is not one of the allowed values \[A,B,C\].$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'G' for parameter DD is not one of the allowed values \[A,B,C\].]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A B\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 34 1 5 A B); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For parameter EE exactly 2 values must be specified. Found: 0.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For parameter EE exactly 2 values must be specified. Found: 0.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A B foo 123\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 34 1 5 A B foo 123); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '123' for parameter EE does not match required pattern '\[a-z\]\+'.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '123' for parameter EE does not match required pattern '\[a-z\]\+'.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A B foo bar\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 34 1 5 A B foo bar); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^AA:aa aa BB:12 34 CC:1 5 DD:A B EE:foo bar FF:$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [AA:aa aa BB:12 34 CC:1 5 DD:A B EE:foo bar FF:]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A B foo bar 123\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 34 1 5 A B foo bar 123); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '123' for parameter FF must only contain characters a-z.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '123' for parameter FF must only contain characters a-z.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa aa 12 34 1 5 A B foo bar a b c d e f\e[22m"
                stdout=$(${FUNCNAME[0]} aa aa 12 34 1 5 A B foo bar a b c d e f); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^AA:aa aa BB:12 34 CC:1 5 DD:A B EE:foo bar FF:a b c d e f$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [AA:aa aa BB:12 34 CC:1 5 DD:A B EE:foo bar FF:a b c d e f]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ${#_AA[@]} -lt 2 ]]; then
            _AA+=("$param")
            continue
        fi
        if [[ ${#_BB[@]} -lt 2 ]]; then
            _BB+=("$param")
            continue
        fi
        if [[ ${#_CC[@]} -lt 2 ]]; then
            _CC+=("$param")
            continue
        fi
        if [[ ${#_DD[@]} -lt 2 ]]; then
            _DD+=("$param")
            continue
        fi
        if [[ ${#_EE[@]} -lt 2 ]]; then
            _EE+=("$param")
            continue
        fi
        _FF+=("$param")
        continue
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ _AA ]]; then
        if [[ ${#_AA[@]} -lt 2 ]]; then echo "Error: For parameter AA exactly 2 values must be specified. Found: ${#_AA[@]}."; return 1; fi
        true
    else
        echo "Error: Parameter AA must be specified."; return 1
    fi
    if [[ _BB ]]; then
        if [[ ${#_BB[@]} -lt 2 ]]; then echo "Error: For parameter BB exactly 2 values must be specified. Found: ${#_BB[@]}."; return 1; fi
        local param
        for param in ${_BB[@]}; do
            if [[ ! "$param" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$param' for parameter BB is not a numeric value."; return 1; fi
        done
        unset param
        true
    else
        echo "Error: Parameter BB must be specified."; return 1
    fi
    if [[ _CC ]]; then
        if [[ ${#_CC[@]} -lt 2 ]]; then echo "Error: For parameter CC exactly 2 values must be specified. Found: ${#_CC[@]}."; return 1; fi
        local param
        for param in ${_CC[@]}; do
            if [[ ! "$param" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$param' for parameter CC is not a numeric value."; return 1; fi
            if [[ $param -lt 1 ]]; then echo "Error: Value '$param' for parameter CC is too low. Must be >= 1."; return 1; fi
            if [[ $param -gt 5 ]]; then echo "Error: Value '$param' for parameter CC is too high. Must be <= 5."; return 1; fi
        done
        unset param
        true
    else
        echo "Error: Parameter CC must be specified."; return 1
    fi
    if [[ _DD ]]; then
        if [[ ${#_DD[@]} -lt 2 ]]; then echo "Error: For parameter DD exactly 2 values must be specified. Found: ${#_DD[@]}."; return 1; fi
        declare -A allowed=([A]=1 [B]=1 [C]=1)
        local param
        for param in ${_DD[@]}; do
            if [[ ! ${allowed[$param]} ]]; then echo "Error: Value '$param' for parameter DD is not one of the allowed values [A,B,C]."; return 1; fi
        done
        unset param allowed
        true
    else
        echo "Error: Parameter DD must be specified."; return 1
    fi
    if [[ _EE ]]; then
        if [[ ${#_EE[@]} -lt 2 ]]; then echo "Error: For parameter EE exactly 2 values must be specified. Found: ${#_EE[@]}."; return 1; fi
        local regex="^[a-z]+$"
        local param
        for param in ${_EE[@]}; do
            if [[ ! "$param" =~ $regex ]]; then echo "Error: Value '$param' for parameter EE does not match required pattern '[a-z]+'."; return 1; fi
        done
        unset param regex
        true
    else
        echo "Error: Parameter EE must be specified."; return 1
    fi
    if [[ _FF ]]; then
        local regex="^[a-z]+$"
        local param
        for param in ${_FF[@]}; do
            if [[ ! "$param" =~ $regex ]]; then echo "Error: Value '$param' for parameter FF must only contain characters a-z."; return 1; fi
        done
        unset param regex
        true
    fi
    
    
    ######################################################

echo "AA:${_AA[@]} BB:${_BB[@]} CC:${_CC[@]} DD:${_DD[@]} EE:${_EE[@]} FF:${_FF[@]}"

}
function _-test-fn-multi-value-parameters() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-fn-multi-value-parameters -- ${BASH_FUNK_PREFIX:-}-test-fn-multi-value-parameters
    
function -test-fn-multi-value-parameters-first-variable() {

    local arg optionWithValue params=() _help _selftest _AA=() _BB=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [AA1..2] BB1 BB2"
                echo 
                echo "Test function with single value parameters."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mAA\e[22m (0 to 2)"
                echo "      Param AA."
                echo -e "  \e[1mBB\e[22m (2 to 2required)"
                echo "      Param BB."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                echo "Error: For parameter BB exactly 2 values must be specified. Found: 0."
                echo -e "$ \e[1m${FUNCNAME[0]} bb\e[22m"
                echo "Error: For parameter BB exactly 2 values must be specified. Found: 1."
                echo -e "$ \e[1m${FUNCNAME[0]} 12 bb\e[22m"
                echo "Error: Value 'bb' for parameter BB is not a numeric value."
                echo -e "$ \e[1m${FUNCNAME[0]} 12 34\e[22m"
                echo "AA: BB:12 34"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 34\e[22m"
                echo "Error: Value 'aa' for parameter AA is not a numeric value."
                echo -e "$ \e[1m${FUNCNAME[0]} 00 aa 12 34\e[22m"
                echo "Error: Value 'aa' for parameter AA is not a numeric value."
                echo -e "$ \e[1m${FUNCNAME[0]} 12 34 bb 12 34\e[22m"
                echo "${FUNCNAME[0]}: too many parameters: '34'.*"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                stdout=$(${FUNCNAME[0]} ); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For parameter BB exactly 2 values must be specified. Found: 0.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For parameter BB exactly 2 values must be specified. Found: 0.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} bb\e[22m"
                stdout=$(${FUNCNAME[0]} bb); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: For parameter BB exactly 2 values must be specified. Found: 1.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: For parameter BB exactly 2 values must be specified. Found: 1.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} 12 bb\e[22m"
                stdout=$(${FUNCNAME[0]} 12 bb); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'bb' for parameter BB is not a numeric value.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'bb' for parameter BB is not a numeric value.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} 12 34\e[22m"
                stdout=$(${FUNCNAME[0]} 12 34); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^AA: BB:12 34$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [AA: BB:12 34]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 34\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12 34); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'aa' for parameter AA is not a numeric value.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'aa' for parameter AA is not a numeric value.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} 00 aa 12 34\e[22m"
                stdout=$(${FUNCNAME[0]} 00 aa 12 34); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'aa' for parameter AA is not a numeric value.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'aa' for parameter AA is not a numeric value.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} 12 34 bb 12 34\e[22m"
                stdout=$(${FUNCNAME[0]} 12 34 bb 12 34); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^${FUNCNAME[0]}: too many parameters: '34'.*$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [${FUNCNAME[0]}: too many parameters: '34'.*]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ${#_AA[@]} -lt 0 ]]; then
            _AA+=("$param")
            continue
        fi
        local leftoverParams=$((${#params[@]} - 2 - ${#_AA[@]}))
        if [[ $leftoverParams -gt 0 ]]; then
            if [[ ${#_AA[@]} -lt 2 ]]; then
                _AA+=("$param")
                continue
            fi
        fi
        if [[ ${#_BB[@]} -lt 2 ]]; then
            _BB+=("$param")
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ _AA ]]; then
        if [[ ${#_AA[@]} -gt 2 ]]; then echo "Error: Too many values for parameter AA specified. Maximum number is 2. Found: ${#_AA[@]}."; return 1; fi
        local param
        for param in ${_AA[@]}; do
            if [[ ! "$param" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$param' for parameter AA is not a numeric value."; return 1; fi
        done
        unset param
        true
    fi
    if [[ _BB ]]; then
        if [[ ${#_BB[@]} -lt 2 ]]; then echo "Error: For parameter BB exactly 2 values must be specified. Found: ${#_BB[@]}."; return 1; fi
        local param
        for param in ${_BB[@]}; do
            if [[ ! "$param" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$param' for parameter BB is not a numeric value."; return 1; fi
        done
        unset param
        true
    else
        echo "Error: Parameter BB must be specified."; return 1
    fi
    
    
    ######################################################

echo "AA:${_AA[@]} BB:${_BB[@]}"

}
function _-test-fn-multi-value-parameters-first-variable() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-fn-multi-value-parameters-first-variable -- ${BASH_FUNK_PREFIX:-}-test-fn-multi-value-parameters-first-variable
    
function -test-fn-noargs() {

    local arg optionWithValue params=() _help _selftest _verbose
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Test function with no arguments."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo -e "\e[1m-v, --verbose\e[22m "
                echo "        Prints additional information during command execution."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                echo 
                echo -e "$ \e[1m${FUNCNAME[0]} --verbose\e[22m"
                echo "verbose mode"
                echo -e "$ \e[1m${FUNCNAME[0]} -f\e[22m"
                echo "${FUNCNAME[0]}: invalid option: '-f'.*"
                echo -e "$ \e[1m${FUNCNAME[0]} --foo\e[22m"
                echo "${FUNCNAME[0]}: invalid option: '--foo'.*"
                echo -e "$ \e[1m${FUNCNAME[0]} FOO\e[22m"
                echo "${FUNCNAME[0]}: too many parameters: 'FOO'.*"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                stdout=$(${FUNCNAME[0]} ); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern []."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --verbose\e[22m"
                stdout=$(${FUNCNAME[0]} --verbose); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^verbose mode$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [verbose mode]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} -f\e[22m"
                stdout=$(${FUNCNAME[0]} -f); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^${FUNCNAME[0]}: invalid option: '-f'.*$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [${FUNCNAME[0]}: invalid option: '-f'.*]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --foo\e[22m"
                stdout=$(${FUNCNAME[0]} --foo); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^${FUNCNAME[0]}: invalid option: '--foo'.*$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [${FUNCNAME[0]}: invalid option: '--foo'.*]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} FOO\e[22m"
                stdout=$(${FUNCNAME[0]} FOO); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^${FUNCNAME[0]}: too many parameters: 'FOO'.*$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [${FUNCNAME[0]}: too many parameters: 'FOO'.*]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            --verbose|-v)
                _verbose=true
            ;;
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

[[ $_verbose ]] && echo "verbose mode" || :

}
function _-test-fn-noargs() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest --verbose -v "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-fn-noargs -- ${BASH_FUNK_PREFIX:-}-test-fn-noargs
    
function -test-fn-requires-existing() {

    local arg optionWithValue params=() _help _selftest _verbose
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Test function that requires presence of an existing command - thus always succeeds."
                echo 
                echo "Requirements:"
                echo "  + Command 'hash' must be available."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo -e "\e[1m-v, --verbose\e[22m "
                echo "        Prints additional information during command execution."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                echo 
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                stdout=$(${FUNCNAME[0]} ); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern []."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            --verbose|-v)
                _verbose=true
            ;;
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    
    if ! hash "hash" &> /dev/null; then echo "Error: Required command 'hash' not found on this system."; return 1; fi
    
    ######################################################

[[ $_verbose ]] && echo "verbose mode" || :

}
function _-test-fn-requires-existing() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest --verbose -v "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-fn-requires-existing -- ${BASH_FUNK_PREFIX:-}-test-fn-requires-existing
    
function -test-fn-requires-nonexistent() {

    local arg optionWithValue params=() _help _selftest _verbose
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Test function that requires presence of a nonexistent command - thus always fails."
                echo 
                echo "Requirements:"
                echo "  + Command 'some_random_nonexistent_command' must be available."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo -e "\e[1m-v, --verbose\e[22m "
                echo "        Prints additional information during command execution."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                echo "Error: Required command 'some_random_nonexistent_command' not found on this system."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                stdout=$(${FUNCNAME[0]} ); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Required command 'some_random_nonexistent_command' not found on this system.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Required command 'some_random_nonexistent_command' not found on this system.]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            --verbose|-v)
                _verbose=true
            ;;
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    
    if ! hash "some_random_nonexistent_command" &> /dev/null; then echo "Error: Required command 'some_random_nonexistent_command' not found on this system."; return 1; fi
    
    ######################################################

[[ $_verbose ]] && echo "verbose mode" || :

}
function _-test-fn-requires-nonexistent() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest --verbose -v "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-fn-requires-nonexistent -- ${BASH_FUNK_PREFIX:-}-test-fn-requires-nonexistent
    
function -test-fn-single-value-options() {

    local arg optionWithValue params=() _aa _aa_value _bb _bb_value _cc _cc_value _dd _dd_value _ee _ee_value _ff _ff_value _gg _gg_value _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Test function with single value options."
                echo 
                echo "Options:"
                echo -e "\e[1m-a, --aa [v]\e[22m "
                echo "        Option a."
                echo -e "\e[1m-b, --bb v\e[22m "
                echo "        Option b."
                echo -e "\e[1m-c, --cc v\e[22m "
                echo "        Option c."
                echo -e "\e[1m-d, --dd v\e[22m "
                echo "        Option d."
                echo -e "\e[1m-e, --ee v\e[22m "
                echo "        Option e."
                echo -e "\e[1m-f, --ff v\e[22m "
                echo "        Option f."
                echo -e "\e[1m-g, --gg v\e[22m "
                echo "        Option g."
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                echo "aa:= bb:= cc:= dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --aa\e[22m"
                echo "aa:true= bb:= cc:= dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --aa foo\e[22m"
                echo "aa:true=foo bb:= cc:= dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --bb\e[22m"
                echo "Error: Value v for option --bb must be specified."
                echo -e "$ \e[1m${FUNCNAME[0]} --bb foo\e[22m"
                echo "aa:= bb:true=foo cc:= dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --cc 12345\e[22m"
                echo "aa:= bb:= cc:true=12345 dd:= ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --cc abc\e[22m"
                echo "Error: Value 'abc' for option --cc is not a numeric value."
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 3\e[22m"
                echo "aa:= bb:= cc:= dd:true=3 ee:= ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 0\e[22m"
                echo "Error: Value '0' for option --dd is too low. Must be >= 1."
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 6\e[22m"
                echo "Error: Value '6' for option --dd is too high. Must be <= 5."
                echo -e "$ \e[1m${FUNCNAME[0]} --ee A\e[22m"
                echo "aa:= bb:= cc:= dd:= ee:true=A ff:= gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --ee F\e[22m"
                echo -e "Error: Value 'F' for option --ee is not one of the allowed values \[A,B,C\]."
                echo -e "$ \e[1m${FUNCNAME[0]} --ff foo\e[22m"
                echo "aa:= bb:= cc:= dd:= ee:= ff:true=foo gg:="
                echo -e "$ \e[1m${FUNCNAME[0]} --ff 123\e[22m"
                echo -e "Error: Value '123' for option --ff does not match required pattern '\[a-z\]\+'."
                echo -e "$ \e[1m${FUNCNAME[0]} --gg 123\e[22m"
                echo "Error: Value '123' for option --gg must only contain characters a-z."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                stdout=$(${FUNCNAME[0]} ); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:= cc:= dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:= cc:= dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --aa\e[22m"
                stdout=$(${FUNCNAME[0]} --aa); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:true= bb:= cc:= dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:true= bb:= cc:= dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --aa foo\e[22m"
                stdout=$(${FUNCNAME[0]} --aa foo); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:true=foo bb:= cc:= dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:true=foo bb:= cc:= dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --bb\e[22m"
                stdout=$(${FUNCNAME[0]} --bb); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value v for option --bb must be specified.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value v for option --bb must be specified.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --bb foo\e[22m"
                stdout=$(${FUNCNAME[0]} --bb foo); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:true=foo cc:= dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:true=foo cc:= dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --cc 12345\e[22m"
                stdout=$(${FUNCNAME[0]} --cc 12345); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:= cc:true=12345 dd:= ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:= cc:true=12345 dd:= ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --cc abc\e[22m"
                stdout=$(${FUNCNAME[0]} --cc abc); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'abc' for option --cc is not a numeric value.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'abc' for option --cc is not a numeric value.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 3\e[22m"
                stdout=$(${FUNCNAME[0]} --dd 3); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:= cc:= dd:true=3 ee:= ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:= cc:= dd:true=3 ee:= ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 0\e[22m"
                stdout=$(${FUNCNAME[0]} --dd 0); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '0' for option --dd is too low. Must be >= 1.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '0' for option --dd is too low. Must be >= 1.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --dd 6\e[22m"
                stdout=$(${FUNCNAME[0]} --dd 6); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '6' for option --dd is too high. Must be <= 5.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '6' for option --dd is too high. Must be <= 5.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --ee A\e[22m"
                stdout=$(${FUNCNAME[0]} --ee A); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:= cc:= dd:= ee:true=A ff:= gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:= cc:= dd:= ee:true=A ff:= gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --ee F\e[22m"
                stdout=$(${FUNCNAME[0]} --ee F); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'F' for option --ee is not one of the allowed values \[A,B,C\].$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'F' for option --ee is not one of the allowed values \[A,B,C\].]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --ff foo\e[22m"
                stdout=$(${FUNCNAME[0]} --ff foo); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^aa:= bb:= cc:= dd:= ee:= ff:true=foo gg:=$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aa:= bb:= cc:= dd:= ee:= ff:true=foo gg:=]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --ff 123\e[22m"
                stdout=$(${FUNCNAME[0]} --ff 123); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '123' for option --ff does not match required pattern '\[a-z\]\+'.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '123' for option --ff does not match required pattern '\[a-z\]\+'.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} --gg 123\e[22m"
                stdout=$(${FUNCNAME[0]} --gg 123); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '123' for option --gg must only contain characters a-z.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '123' for option --gg must only contain characters a-z.]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
            --aa|-a)
                _aa=true
                _aa_value=
                optionWithValue=--aa
            ;;
    
            --bb|-b)
                _bb=true
                _bb_value=
                optionWithValue=--bb
            ;;
    
            --cc|-c)
                _cc=true
                _cc_value=
                optionWithValue=--cc
            ;;
    
            --dd|-d)
                _dd=true
                _dd_value=
                optionWithValue=--dd
            ;;
    
            --ee|-e)
                _ee=true
                _ee_value=
                optionWithValue=--ee
            ;;
    
            --ff|-f)
                _ff=true
                _ff_value=
                optionWithValue=--ff
            ;;
    
            --gg|-g)
                _gg=true
                _gg_value=
                optionWithValue=--gg
            ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    --aa)
                        _aa_value=$arg
                        optionWithValue=
                      ;;
                    --bb)
                        _bb_value=$arg
                        optionWithValue=
                      ;;
                    --cc)
                        _cc_value=$arg
                        optionWithValue=
                      ;;
                    --dd)
                        _dd_value=$arg
                        optionWithValue=
                      ;;
                    --ee)
                        _ee_value=$arg
                        optionWithValue=
                      ;;
                    --ff)
                        _ff_value=$arg
                        optionWithValue=
                      ;;
                    --gg)
                        _gg_value=$arg
                        optionWithValue=
                      ;;
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    if [[ $_aa ]]; then
        true
    fi
    if [[ $_bb ]]; then
        if [[ ! $_bb_value ]]; then echo "Error: Value v for option --bb must be specified."; return 1; fi
        true
    fi
    if [[ $_cc ]]; then
        if [[ ! $_cc_value ]]; then echo "Error: Value v for option --cc must be specified."; return 1; fi
        if [[ ! "$_cc_value" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_cc_value' for option --cc is not a numeric value."; return 1; fi
        true
    fi
    if [[ $_dd ]]; then
        if [[ ! $_dd_value ]]; then echo "Error: Value v for option --dd must be specified."; return 1; fi
        if [[ ! "$_dd_value" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_dd_value' for option --dd is not a numeric value."; return 1; fi
        if [[ $_dd_value -lt 1 ]]; then echo "Error: Value '$_dd_value' for option --dd is too low. Must be >= 1."; return 1; fi
        if [[ $_dd_value -gt 5 ]]; then echo "Error: Value '$_dd_value' for option --dd is too high. Must be <= 5."; return 1; fi
        true
    fi
    if [[ $_ee ]]; then
        if [[ ! $_ee_value ]]; then echo "Error: Value v for option --ee must be specified."; return 1; fi
        declare -A allowed=( [A]=1 [B]=1 [C]=1 )
        if [[ ! ${allowed[$_ee_value]} ]]; then echo "Error: Value '$_ee_value' for option --ee is not one of the allowed values [A,B,C]."; return 1; fi
        unset allowed
        true
    fi
    if [[ $_ff ]]; then
        if [[ ! $_ff_value ]]; then echo "Error: Value v for option --ff must be specified."; return 1; fi
        local regex="^[a-z]+$"
        if [[ ! "$_ff_value" =~ $regex ]]; then echo "Error: Value '$_ff_value' for option --ff does not match required pattern '[a-z]+'."; return 1; fi
        unset regex
        true
    fi
    if [[ $_gg ]]; then
        if [[ ! $_gg_value ]]; then echo "Error: Value v for option --gg must be specified."; return 1; fi
        local regex="^[a-z]+$"
        if [[ ! "$_gg_value" =~ $regex ]]; then echo "Error: Value '$_gg_value' for option --gg must only contain characters a-z."; return 1; fi
        unset regex
        true
    fi
    
    
    
    ######################################################

echo "aa:$_aa=$_aa_value bb:$_bb=$_bb_value cc:$_cc=$_cc_value dd:$_dd=$_dd_value ee:$_ee=$_ee_value ff:$_ff=$_ff_value gg:$_gg=$_gg_value"

}
function _-test-fn-single-value-options() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --aa -a --bb -b --cc -c --dd -d --ee -e --ff -f --gg -g --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-fn-single-value-options -- ${BASH_FUNK_PREFIX:-}-test-fn-single-value-options
    
function -test-fn-single-value-parameters() {

    local arg optionWithValue params=() _help _selftest _AA _BB _CC _DD _EE _FF
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... AA BB CC DD EE [FF]"
                echo 
                echo "Test function with single value parameters."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mAA\e[22m (required)"
                echo "      Param AA."
                echo -e "  \e[1mBB\e[22m (required)"
                echo "      Param BB."
                echo -e "  \e[1mCC\e[22m (required)"
                echo "      Param CC."
                echo -e "  \e[1mDD\e[22m (required)"
                echo "      Param DD."
                echo -e "  \e[1mEE\e[22m (required)"
                echo "      Param EE."
                echo -e "  \e[1mFF\e[22m "
                echo "      Param FF."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                echo "Error: Parameter AA must be specified."
                echo -e "$ \e[1m${FUNCNAME[0]} aa\e[22m"
                echo "Error: Parameter BB must be specified."
                echo -e "$ \e[1m${FUNCNAME[0]} aa bb\e[22m"
                echo "Error: Value 'bb' for parameter BB is not a numeric value."
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12\e[22m"
                echo "Error: Parameter CC must be specified."
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 0\e[22m"
                echo "Error: Value '0' for parameter CC is too low. Must be >= 1."
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 6\e[22m"
                echo "Error: Value '6' for parameter CC is too high. Must be <= 5."
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5\e[22m"
                echo "Error: Parameter DD must be specified."
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 G\e[22m"
                echo -e "Error: Value 'G' for parameter DD is not one of the allowed values \[A,B,C\]."
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 A\e[22m"
                echo "Error: Parameter EE must be specified."
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 A 123\e[22m"
                echo -e "Error: Value '123' for parameter EE does not match required pattern '\[a-z\]\+'."
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 A foo\e[22m"
                echo "AA:aa BB:12 CC:5 DD:A EE:foo FF:"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 A foo 123\e[22m"
                echo "Error: Value '123' for parameter FF must only contain characters a-z."
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 A foo bar\e[22m"
                echo "AA:aa BB:12 CC:5 DD:A EE:foo FF:bar"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                stdout=$(${FUNCNAME[0]} ); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Parameter AA must be specified.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Parameter AA must be specified.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa\e[22m"
                stdout=$(${FUNCNAME[0]} aa); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Parameter BB must be specified.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Parameter BB must be specified.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa bb\e[22m"
                stdout=$(${FUNCNAME[0]} aa bb); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'bb' for parameter BB is not a numeric value.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'bb' for parameter BB is not a numeric value.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Parameter CC must be specified.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Parameter CC must be specified.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 0\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12 0); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '0' for parameter CC is too low. Must be >= 1.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '0' for parameter CC is too low. Must be >= 1.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 6\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12 6); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '6' for parameter CC is too high. Must be <= 5.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '6' for parameter CC is too high. Must be <= 5.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12 5); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Parameter DD must be specified.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Parameter DD must be specified.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 G\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12 5 G); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'G' for parameter DD is not one of the allowed values \[A,B,C\].$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'G' for parameter DD is not one of the allowed values \[A,B,C\].]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 A\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12 5 A); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Parameter EE must be specified.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Parameter EE must be specified.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 A 123\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12 5 A 123); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '123' for parameter EE does not match required pattern '\[a-z\]\+'.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '123' for parameter EE does not match required pattern '\[a-z\]\+'.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 A foo\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12 5 A foo); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^AA:aa BB:12 CC:5 DD:A EE:foo FF:$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [AA:aa BB:12 CC:5 DD:A EE:foo FF:]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 A foo 123\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12 5 A foo 123); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value '123' for parameter FF must only contain characters a-z.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value '123' for parameter FF must only contain characters a-z.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 12 5 A foo bar\e[22m"
                stdout=$(${FUNCNAME[0]} aa 12 5 A foo bar); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^AA:aa BB:12 CC:5 DD:A EE:foo FF:bar$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [AA:aa BB:12 CC:5 DD:A EE:foo FF:bar]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_AA ]]; then
            _AA=$param
            continue
        fi
        if [[ ! $_BB ]]; then
            _BB=$param
            continue
        fi
        if [[ ! $_CC ]]; then
            _CC=$param
            continue
        fi
        if [[ ! $_DD ]]; then
            _DD=$param
            continue
        fi
        if [[ ! $_EE ]]; then
            _EE=$param
            continue
        fi
        if [[ ! $_FF ]]; then
            _FF=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_AA ]]; then
        true
    else
        echo "Error: Parameter AA must be specified."; return 1
    fi
    if [[ $_BB ]]; then
        if [[ ! "$_BB" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_BB' for parameter BB is not a numeric value."; return 1; fi
        true
    else
        echo "Error: Parameter BB must be specified."; return 1
    fi
    if [[ $_CC ]]; then
        if [[ ! "$_CC" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_CC' for parameter CC is not a numeric value."; return 1; fi
        if [[ $_CC -lt 1 ]]; then echo "Error: Value '$_CC' for parameter CC is too low. Must be >= 1."; return 1; fi
        if [[ $_CC -gt 5 ]]; then echo "Error: Value '$_CC' for parameter CC is too high. Must be <= 5."; return 1; fi
        true
    else
        echo "Error: Parameter CC must be specified."; return 1
    fi
    if [[ $_DD ]]; then
        declare -A allowed=( [A]=1 [B]=1 [C]=1 )
        if [[ ! ${allowed[$_DD]} ]]; then echo "Error: Value '$_DD' for parameter DD is not one of the allowed values [A,B,C]."; return 1; fi
        unset allowed
        true
    else
        echo "Error: Parameter DD must be specified."; return 1
    fi
    if [[ $_EE ]]; then
        local regex="^[a-z]+$"
        if [[ ! "$_EE" =~ $regex ]]; then echo "Error: Value '$_EE' for parameter EE does not match required pattern '[a-z]+'."; return 1; fi
        unset regex
        true
    else
        echo "Error: Parameter EE must be specified."; return 1
    fi
    if [[ $_FF ]]; then
        local regex="^[a-z]+$"
        if [[ ! "$_FF" =~ $regex ]]; then echo "Error: Value '$_FF' for parameter FF must only contain characters a-z."; return 1; fi
        unset regex
        true
    fi
    
    
    ######################################################

echo "AA:$_AA BB:$_BB CC:$_CC DD:$_DD EE:$_EE FF:$_FF"

}
function _-test-fn-single-value-parameters() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-fn-single-value-parameters -- ${BASH_FUNK_PREFIX:-}-test-fn-single-value-parameters
    
function -test-fn-single-value-parameters-first-optional() {

    local arg optionWithValue params=() _help _selftest _AA _BB
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [AA] BB"
                echo 
                echo "Test function with single value parameters where the first one is optional."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mAA\e[22m "
                echo "      Param AA."
                echo -e "  \e[1mBB\e[22m (required)"
                echo "      Param BB."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                echo "Error: Parameter BB must be specified."
                echo -e "$ \e[1m${FUNCNAME[0]} bb\e[22m"
                echo "Error: Value 'bb' for parameter BB is not a numeric value."
                echo -e "$ \e[1m${FUNCNAME[0]} 22\e[22m"
                echo "AA: BB:22"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 22\e[22m"
                echo "Error: Value 'aa' for parameter AA is not a numeric value."
                echo -e "$ \e[1m${FUNCNAME[0]} 11 22\e[22m"
                echo "AA:11 BB:22"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} \e[22m"
                stdout=$(${FUNCNAME[0]} ); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Parameter BB must be specified.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Parameter BB must be specified.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} bb\e[22m"
                stdout=$(${FUNCNAME[0]} bb); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'bb' for parameter BB is not a numeric value.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'bb' for parameter BB is not a numeric value.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} 22\e[22m"
                stdout=$(${FUNCNAME[0]} 22); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^AA: BB:22$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [AA: BB:22]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} aa 22\e[22m"
                stdout=$(${FUNCNAME[0]} aa 22); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1]."; return 1; fi
                regex="^Error: Value 'aa' for parameter AA is not a numeric value.$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Error: Value 'aa' for parameter AA is not a numeric value.]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} 11 22\e[22m"
                stdout=$(${FUNCNAME[0]} 11 22); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^AA:11 BB:22$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [AA:11 BB:22]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_AA && ${#params[@]} > 1 ]]; then
            _AA=$param
            continue
        fi
        if [[ ! $_BB ]]; then
            _BB=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_AA ]]; then
        if [[ ! "$_AA" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_AA' for parameter AA is not a numeric value."; return 1; fi
        true
    fi
    if [[ $_BB ]]; then
        if [[ ! "$_BB" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_BB' for parameter BB is not a numeric value."; return 1; fi
        true
    else
        echo "Error: Parameter BB must be specified."; return 1
    fi
    
    
    ######################################################

echo "AA:$_AA BB:$_BB"

}
function _-test-fn-single-value-parameters-first-optional() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-fn-single-value-parameters-first-optional -- ${BASH_FUNK_PREFIX:-}-test-fn-single-value-parameters-first-optional
    
function -test-test() {

    local arg optionWithValue params=() _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

${BASH_FUNK_PREFIX:-}-test-fn-flags --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-test-fn-multi-value-options --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-test-fn-multi-value-parameters --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-test-fn-multi-value-parameters-first-variable --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-test-fn-noargs --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-test-fn-requires-existing --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-test-fn-requires-nonexistent --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-test-fn-single-value-options --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-test-fn-single-value-parameters --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-test-fn-single-value-parameters-first-optional --selftest && echo || return 1
}
function _-test-test() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-test -- ${BASH_FUNK_PREFIX:-}-test-test

function -help-test() {

    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-fn-flags\e[0m  -  Test function with custom flags."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-fn-multi-value-options\e[0m  -  Test function with multi value options."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-fn-multi-value-parameters AA1 AA2 BB1 BB2 CC1 CC2 DD1 DD2 EE1 EE2 [FF]...\e[0m  -  Test function with single value parameters."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-fn-multi-value-parameters-first-variable [AA1..2] BB1 BB2\e[0m  -  Test function with single value parameters."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-fn-noargs\e[0m  -  Test function with no arguments."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-fn-requires-existing\e[0m  -  Test function that requires presence of an existing command - thus always succeeds."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-fn-requires-nonexistent\e[0m  -  Test function that requires presence of a nonexistent command - thus always fails."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-fn-single-value-options\e[0m  -  Test function with single value options."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-fn-single-value-parameters AA BB CC DD EE [FF]\e[0m  -  Test function with single value parameters."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-fn-single-value-parameters-first-optional [AA] BB\e[0m  -  Test function with single value parameters where the first one is optional."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-test\e[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."

}

