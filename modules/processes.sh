#!/bin/bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
    
function -get-child-pids() {

    local arg optionWithValue params=() _printPPID _help _selftest _PARENT_PID
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [PARENT_PID]"
                echo 
                echo "Recursively prints all child PIDs of the process with the given PID."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mPARENT_PID\e[22m "
                echo "      The process ID of the parent process. If not specified the PID of the current Bash process is used."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --printPPID\e[22m "
                echo "        Specifies to also print the PID of the parent process."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
            --printPPID)
                _printPPID=true
            ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PARENT_PID && ${#params[@]} > 0 ]]; then
            _PARENT_PID=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_PARENT_PID ]]; then
        if [[ ! "$_PARENT_PID" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_PARENT_PID' for parameter PARENT_PID is not a numeric value."; return 1; fi
        true
    fi
    
    
    ######################################################

if [[ ! $_PARENT_PID ]]; then _PARENT_PID=$$; fi
local CHILD_PIDS # intentional declaration in a separate line, see http://stackoverflow.com/a/42854176
childPids=$(command ps -o pid --no-headers --ppid $_PARENT_PID 2>/dev/null | sed -e 's!\s!!g'; exit ${PIPESTATUS[0]})
if [[ $? != 0 ]]; then
    echo "No process with PID ${1} found"'!'
    return 1
fi
for childPid in $childPids; do
    ${FUNCNAME[0]} --printPPID $childPid
done
if [[ $_printPPID ]]; then
    echo $_PARENT_PID
fi

}
function _-get-child-pids() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --printPPID --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-get-child-pids -- ${BASH_FUNK_PREFIX:-}-get-child-pids
    
function -get-parent-pid() {

    local arg optionWithValue params=() _help _selftest _CHILD_PID
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [CHILD_PID]"
                echo 
                echo "Prints the PID of the parent process of the child process with the given PID."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mCHILD_PID\e[22m "
                echo "      The process ID of the child process. If not specified the PID of the current Bash process is used."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_CHILD_PID && ${#params[@]} > 0 ]]; then
            _CHILD_PID=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_CHILD_PID ]]; then
        if [[ ! "$_CHILD_PID" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_CHILD_PID' for parameter CHILD_PID is not a numeric value."; return 1; fi
        true
    fi
    
    
    ######################################################

if [[ ! $_CHILD_PID ]]; then _CHILD_PID=$$; fi
local parentPid # intentional declaration in a separate line, see http://stackoverflow.com/a/42854176
parentPid=$(cat /proc/${_CHILD_PID}/stat 2>/dev/null | awk '{print $4}'; exit ${PIPESTATUS[0]})
if [[ $? != 0 ]]; then
    echo "No process with PID ${_CHILD_PID} found"'!'
    return 1
fi
echo $parentPid

}
function _-get-parent-pid() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-get-parent-pid -- ${BASH_FUNK_PREFIX:-}-get-parent-pid
    
function -get-toplevel-parent-pid() {

    local arg optionWithValue params=() _help _selftest _CHILD_PID
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [CHILD_PID]"
                echo 
                echo "Prints the PID of the top-level parent process of the child process with the given PID."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mCHILD_PID\e[22m "
                echo "      The process ID of the child process. If not specified the PID of the current Bash process is used."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_CHILD_PID && ${#params[@]} > 0 ]]; then
            _CHILD_PID=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_CHILD_PID ]]; then
        if [[ ! "$_CHILD_PID" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_CHILD_PID' for parameter CHILD_PID is not a numeric value."; return 1; fi
        true
    fi
    
    
    ######################################################

if [[ $_CHILD_PID ]]; then _CHILD_PID=$$; fi
local pid=$_CHILD_PID
while [[ $pid != 0 ]]; do
    pid=$(${BASH_FUNK_PREFIX}-get-parent-pid ${pid})
    if [[ $? != 0 ]]; then
        echo $pid
        return 1
    fi
done
echo ${pid}

}
function _-get-toplevel-parent-pid() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-get-toplevel-parent-pid -- ${BASH_FUNK_PREFIX:-}-get-toplevel-parent-pid
    
function -kill-childs() {

    local arg optionWithValue params=() _help _selftest _SIGNAL _PARENT_PID
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... SIGNAL [PARENT_PID]"
                echo 
                echo "Sends the given kill signal to all child processes of the process with the given PID."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSIGNAL\e[22m (required)"
                echo "      The kill signal to be send, eg. 9=KILL or 15=TERM."
                echo -e "  \e[1mPARENT_PID\e[22m "
                echo "      The process ID of the parent process. If not specified the PID of the current bash process is used."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_SIGNAL ]]; then
            _SIGNAL=$param
            continue
        fi
        if [[ ! $_PARENT_PID ]]; then
            _PARENT_PID=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_SIGNAL ]]; then
        if [[ ! "$_SIGNAL" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_SIGNAL' for parameter SIGNAL is not a numeric value."; return 1; fi
        true
    else
        echo "Error: Parameter SIGNAL must be specified."; return 1
    fi
    if [[ $_PARENT_PID ]]; then
        if [[ ! "$_PARENT_PID" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_PARENT_PID' for parameter PARENT_PID is not a numeric value."; return 1; fi
        true
    fi
    
    
    ######################################################

if [[ ! $_PARENT_PID ]]; then _PARENT_PID=$$; fi
local childPids=$(${BASH_FUNK_PREFIX}-get-child-pids $_PARENT_PID)
if [[ $? != 0 ]]; then
    echo $childPids
    return 1
fi
for childPid in $childPids; do
    echo "Killing process with PID $childPid..."
    kill -s $_SIGNAL $childPid 2> /dev/null || :
done

}
function _-kill-childs() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-kill-childs -- ${BASH_FUNK_PREFIX:-}-kill-childs
    
function -test-processes() {

    local arg optionWithValue params=() _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

${BASH_FUNK_PREFIX:-}-get-child-pids --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-get-parent-pid --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-get-toplevel-parent-pid --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-kill-childs --selftest && echo || return 1
}
function _-test-processes() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-processes -- ${BASH_FUNK_PREFIX:-}-test-processes

function -help-processes() {

    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-get-child-pids [PARENT_PID]\e[0m  -  Recursively prints all child PIDs of the process with the given PID."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-get-parent-pid [CHILD_PID]\e[0m  -  Prints the PID of the parent process of the child process with the given PID."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-get-toplevel-parent-pid [CHILD_PID]\e[0m  -  Prints the PID of the top-level parent process of the child process with the given PID."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-kill-childs SIGNAL [PARENT_PID]\e[0m  -  Sends the given kill signal to all child processes of the process with the given PID."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-processes\e[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."

}

