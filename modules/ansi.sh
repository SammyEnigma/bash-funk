#!/bin/bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
    
function -ansi-bold() {

    local arg optionWithValue params=() _on _off _help _selftest _TEXT
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [TEXT]"
                echo 
                echo "Sets bold mode or prints the given text in bold."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mTEXT\e[22m "
                echo "      The text to print in bold."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --off\e[22m "
                echo "        Print the ANSI escape sequence that disables sets bold attribute."
                echo -e "\e[1m    --on\e[22m "
                echo "        Print the ANSI escape sequence that enables sets bold attribute."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
            --on)
                _on=true
            ;;
    
            --off)
                _off=true
            ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_TEXT && ${#params[@]} > 0 ]]; then
            _TEXT=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_TEXT ]]; then
        true
    fi
    
    
    ######################################################

if [[ $_TEXT ]]; then
    echo -ne "\e[1m$_TEXT\e[22m"
fi

if [[ $_on ]]; then
    echo -ne "\e[1m"
elif [[ $_off ]]; then
    echo -ne "\e[22m"
fi

}
function _-ansi-bold() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --on --off --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-ansi-bold -- ${BASH_FUNK_PREFIX:-}-ansi-bold
    
function -ansi-colors-supported() {

    local arg optionWithValue params=() _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Determines if ANSI color escape sequences are supported by the current terminal."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

if hash tput &>/dev/null; then
    ncolors=$(tput colors)
    if [[ $ncolors -ge 8 ]]; then
        return 0
    else
        return 1
    fi

elif hash infocmp &>/dev/null; then
    infocmp $TERM 2>/dev/null | grep "colors#8" >/dev/null
    return

elif [[ $TERM == "cygwin" ]]; then
    return 0
fi

return 1

}
function _-ansi-colors-supported() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-ansi-colors-supported -- ${BASH_FUNK_PREFIX:-}-ansi-colors-supported
    
function -ansi-reset() {

    local arg optionWithValue params=() _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Prints an ANSI escape sequence that reset all ANSI attributes."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

echo -ne "\e[0m"

}
function _-ansi-reset() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-ansi-reset -- ${BASH_FUNK_PREFIX:-}-ansi-reset
    
function -ansi-ul() {

    local arg optionWithValue params=() _on _off _help _selftest _TEXT
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [TEXT]"
                echo 
                echo "Sets underlined mode or prints the given text underlined."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mTEXT\e[22m "
                echo "      The text to print underlined."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --off\e[22m "
                echo "        Print the ANSI escape sequence that disables sets underlined attribute."
                echo -e "\e[1m    --on\e[22m "
                echo "        Print the ANSI escape sequence that enables sets underlined attribute."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
            --on)
                _on=true
            ;;
    
            --off)
                _off=true
            ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_TEXT && ${#params[@]} > 0 ]]; then
            _TEXT=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_TEXT ]]; then
        true
    fi
    
    
    ######################################################

if [[ $_TEXT ]]; then
    echo -ne "\e[4m$_TEXT\e[24m"
fi

if [[ $_on ]]; then
    echo -ne "\e[4m"
elif [[ $_off ]]; then
    echo -ne "\e[24m"
fi

}
function _-ansi-ul() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --on --off --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-ansi-ul -- ${BASH_FUNK_PREFIX:-}-ansi-ul
    
function -test-ansi() {

    local arg optionWithValue params=() _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

${BASH_FUNK_PREFIX:-}-ansi-bold --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-ansi-colors-supported --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-ansi-reset --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-ansi-ul --selftest && echo || return 1
}
function _-test-ansi() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-ansi -- ${BASH_FUNK_PREFIX:-}-test-ansi

function -help-ansi() {

    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-ansi-bold [TEXT]\e[0m  -  Sets bold mode or prints the given text in bold."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-ansi-colors-supported\e[0m  -  Determines if ANSI color escape sequences are supported by the current terminal."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-ansi-reset\e[0m  -  Prints an ANSI escape sequence that reset all ANSI attributes."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-ansi-ul [TEXT]\e[0m  -  Sets underlined mode or prints the given text underlined."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-ansi\e[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."

}

