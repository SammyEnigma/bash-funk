#!/usr/bin/env bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
function -ansi-bold() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [TEXT]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ansi-bold() {
    local __arg __optionWithValue __params=() __in_subshell __in_pipe __fn=${FUNCNAME[0]/__impl/} _on _off _help _selftest _TEXT
    [ -p /dev/stdout ] && __in_pipe=1 || true
    [ -t 1 ] || __in_subshell=1
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [TEXT]"
                echo
                echo "Sets bold mode or prints the given text in bold."
                echo
                echo "Parameters:"
                echo -e "  \033[1mTEXT\033[22m "
                echo "      The text to print in bold."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --off\033[22m "
                echo "        Print the ANSI escape sequence that disables sets bold attribute."
                echo -e "\033[1m    --on\033[22m "
                echo "        Print the ANSI escape sequence that enables sets bold attribute."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --on)
                _on=1
            ;;

            --off)
                _off=1
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_TEXT && ${#__params[@]} > 0 ]]; then
            _TEXT=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### ansi-bold ######### START

if [[ $_TEXT ]]; then
    echo -ne "\033[1m$_TEXT\033[22m"
fi

if [[ $_on ]]; then
    echo -ne "\033[1m"
elif [[ $_off ]]; then
    echo -ne "\033[22m"
fi

    ######### ansi-bold ######### END
}
function __complete-ansi-bold() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --on --off --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-bold -- ${BASH_FUNK_PREFIX:--}ansi-bold

function -ansi-codes() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PREFIX]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ansi-codes() {
    local __arg __optionWithValue __params=() __in_subshell __in_pipe __fn=${FUNCNAME[0]/__impl/} _escape _help _selftest _PREFIX
    [ -p /dev/stdout ] && __in_pipe=1 || true
    [ -t 1 ] || __in_subshell=1
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [PREFIX]"
                echo
                echo "Prints commands to set variables with common ANSI codes. When used with the 'echo' command, the -e option is not required."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPREFIX\033[22m (default: 'ANSI_')"
                echo "      Prefix to be used for the declared variables."
                echo
                echo "Options:"
                echo -e "\033[1m-e, --escape\033[22m "
                echo "        If specified the escape code will be printed as octal value ."
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --escape|-e)
                _escape=1
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PREFIX && ${#__params[@]} > 0 ]]; then
            _PREFIX=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_PREFIX ]]; then _PREFIX="ANSI_"; fi

    ######### ansi-codes ######### START

if [[ $_escape ]]; then
    local ESC="\033";
else
    local ESC=$(echo -e "\033");
fi

echo "
${_PREFIX}RESET=\"$ESC[0m\"
${_PREFIX}BOLD=\"$ESC[1m\"
${_PREFIX}BOLD_OFF=\"$ESC[22m\"
${_PREFIX}ITALIC=\"$ESC[3m\"
${_PREFIX}UNDERLINE=\"$ESC[4m\"
${_PREFIX}UNDERLINE_DOUBLE=\"$ESC[21m\"
${_PREFIX}UNDERLINE_OFF=\"$ESC[24m\"
${_PREFIX}BLINK_SLOW=\"$ESC[5m\"
${_PREFIX}BLINK_FAST=\"$ESC[6m\"
${_PREFIX}BLINK_OFF=\"$ESC[25m\"
${_PREFIX}INVERT=\"$ESC[7m\"
${_PREFIX}INVERT_OFF=\"$ESC[27m\"

${_PREFIX}FG_BLACK=\"$ESC[30m\"
${_PREFIX}FG_RED=\"$ESC[31m\"
${_PREFIX}FG_GREEN=\"$ESC[32m\"
${_PREFIX}FG_YELLOW=\"$ESC[33m\"
${_PREFIX}FG_BLUE=\"$ESC[34m\"
${_PREFIX}FG_MAGENTA=\"$ESC[35m\"
${_PREFIX}FG_CYAN=\"$ESC[36m\"
${_PREFIX}FG_GRAY=\"$ESC[37m\"

${_PREFIX}FG_LIGHT_RED=\"$ESC[91m\"
${_PREFIX}FG_LIGHT_GREEN=\"$ESC[92m\"
${_PREFIX}FG_LIGHT_YELLOW=\"$ESC[93m\"
${_PREFIX}FG_LIGHT_BLUE=\"$ESC[94m\"
${_PREFIX}FG_LIGHT_MAGENTA=\"$ESC[95m\"
${_PREFIX}FG_LIGHT_CYAN=\"$ESC[96m\"
${_PREFIX}FG_WHITE=\"$ESC[97m\"

${_PREFIX}BG_BLACK=\"$ESC[40m\"
${_PREFIX}BG_RED=\"$ESC[41m\"
${_PREFIX}BG_GREEN=\"$ESC[42m\"
${_PREFIX}BG_YELLOW=\"$ESC[43m\"
${_PREFIX}BG_BLUE=\"$ESC[44m\"
${_PREFIX}BG_MAGENTA=\"$ESC[45m\"
${_PREFIX}BG_CYAN=\"$ESC[46m\"
${_PREFIX}BG_GRAY=\"$ESC[47m\"

${_PREFIX}BG_LIGHT_BLACK=\"$ESC[100m\"
${_PREFIX}BG_LIGHT_RED=\"$ESC[101m\"
${_PREFIX}BG_LIGHT_GREEN=\"$ESC[102m\"
${_PREFIX}BG_LIGHT_YELLOW=\"$ESC[103m\"
${_PREFIX}BG_LIGHT_BLUE=\"$ESC[104m\"
${_PREFIX}BG_LIGHT_MAGENTA=\"$ESC[105m\"
${_PREFIX}BG_LIGHT_CYAN=\"$ESC[106m\"
${_PREFIX}BG_WHITE=\"$ESC[107m\"
"

    ######### ansi-codes ######### END
}
function __complete-ansi-codes() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --escape -e --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-codes -- ${BASH_FUNK_PREFIX:--}ansi-codes

function -ansi-colors-supported() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [NUM_COLORS]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ansi-colors-supported() {
    local __arg __optionWithValue __params=() __in_subshell __in_pipe __fn=${FUNCNAME[0]/__impl/} _help _selftest _verbose _NUM_COLORS
    [ -p /dev/stdout ] && __in_pipe=1 || true
    [ -t 1 ] || __in_subshell=1
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [NUM_COLORS]"
                echo
                echo "Determines if the given number of ANSI colors is supported by the current terminal. If NUM_COLORS is specified, the exit value indicates if the color range is supported. If NUM_COLORS is not specified, the number of supported colors is printed with exit code 0."
                echo
                echo "Parameters:"
                echo -e "  \033[1mNUM_COLORS\033[22m "
                echo "      Number of colors that need to be supported."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo -e "\033[1m-v, --verbose\033[22m "
                echo "        Prints additional information during command execution."
                echo
                echo "Examples:"
                echo -e "$ \033[1m$__fn \033[22m"
                echo "256"
                echo -e "$ \033[1m$__fn -v 8\033[22m"
                echo "Terminal 'xterm' supports 8 colors."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn \033[22m"
                __stdout="$($__fn )"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^[0-9]+$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [[0-9]+]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn -v 8\033[22m"
                __stdout="$($__fn -v 8)"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^Terminal '.*' supports [0-9]+ colors.$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Terminal '.*' supports [0-9]+ colors.]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --verbose|-v)
                _verbose=1
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_NUM_COLORS && ${#__params[@]} > 0 ]]; then
            _NUM_COLORS=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### ansi-colors-supported ######### START

local numColors
if hash tput &>/dev/null; then
    numColors=$(tput colors)
elif hash infocmp &>/dev/null; then
    local termInfo=$(infocmp $TERM || true);
    if [[ $termInfo =~ colors#([0-9]+), ]]; then
        local numColors=${BASH_REMATCH[1]}
    else
        numColors=-1
    fi
elif [[ $TERM == "cygwin" ]]; then
    numColors=8
else
    numColors=-1
fi

if [[ $_NUM_COLORS ]]; then
    if [[ $numColors -ge $_NUM_COLORS ]]; then
        [[ $_verbose ]] && echo "Terminal '$TERM' supports $numColors colors."
        return 0
    else
        [[ $_verbose ]] && echo "Terminal '$TERM' supports only $numColors colors."
        return 1
    fi
else
    echo $numColors
    return 0
fi

    ######### ansi-colors-supported ######### END
}
function __complete-ansi-colors-supported() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest --verbose -v "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-colors-supported -- ${BASH_FUNK_PREFIX:--}ansi-colors-supported

function -ansi-colors16() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ansi-colors16() {
    local __arg __optionWithValue __params=() __in_subshell __in_pipe __fn=${FUNCNAME[0]/__impl/} _help _selftest
    [ -p /dev/stdout ] && __in_pipe=1 || true
    [ -t 1 ] || __in_subshell=1
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]..."
                echo
                echo "Prints a table with 8/16 ANSI colors."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                echo "Examples:"
                echo -e "$ \033[1m$__fn \033[22m"
                echo "256"
                echo -e "$ \033[1m$__fn -v 8\033[22m"
                echo "Terminal 'xterm' supports 8 colors."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn \033[22m"
                __stdout="$($__fn )"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^[0-9]+$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [[0-9]+]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn -v 8\033[22m"
                __stdout="$($__fn -v 8)"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^Terminal '.*' supports [0-9]+ colors.$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Terminal '.*' supports [0-9]+ colors.]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### ansi-colors16 ######### START


if ! ${BASH_FUNK_PREFIX:--}ansi-colors-supported 8; then
    echo "WARNING: Your current terminal '$TERM' is reported to not support displaying 8 colors."
    echo
elif ! ${BASH_FUNK_PREFIX:--}ansi-colors-supported 16; then
    echo "WARNING: Your current terminal '$TERM' is reported to not support displaying 16 colors."
    echo
fi

echo "To set one of the following color combinations use '\033[<BG>;<FG>m'"
echo
echo -n "      "
for fg in {30..37} 39 {90..97}; do
    printf "  FG %2d" "$fg"
done
echo
for bg in {40..47} 49 {100..107}; do
    printf "BG %3d " "$bg"
    for fg in {30..37} 39 {90..97}; do
        printf "\033[${bg};${fg}m%3d;%2d\033[0m " "$bg" "$fg"
    done
    echo
done

    ######### ansi-colors16 ######### END
}
function __complete-ansi-colors16() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-colors16 -- ${BASH_FUNK_PREFIX:--}ansi-colors16

function -ansi-colors256() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ansi-colors256() {
    local __arg __optionWithValue __params=() __in_subshell __in_pipe __fn=${FUNCNAME[0]/__impl/} _help _selftest
    [ -p /dev/stdout ] && __in_pipe=1 || true
    [ -t 1 ] || __in_subshell=1
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]..."
                echo
                echo "Prints a table with 256 ANSI colors."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                echo "Examples:"
                echo -e "$ \033[1m$__fn \033[22m"
                echo "256"
                echo -e "$ \033[1m$__fn -v 8\033[22m"
                echo "Terminal 'xterm' supports 8 colors."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn \033[22m"
                __stdout="$($__fn )"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^[0-9]+$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [[0-9]+]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn -v 8\033[22m"
                __stdout="$($__fn -v 8)"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^Terminal '.*' supports [0-9]+ colors.$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Terminal '.*' supports [0-9]+ colors.]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### ansi-colors256 ######### START


if ! ${BASH_FUNK_PREFIX:--}ansi-colors-supported 256; then
    echo "WARNING: Your current terminal '$TERM' is reported to not support displaying 256 colors."
    echo
fi

local i width

if [[ $COLUMNS -lt 144 ]]; then
	width=$(( COLUMNS / 6 ))
else
	width=36
fi

echo "To set one of the following foreground colors use '\033[38;5;<NUM>m'"
echo
for (( i=0; i<256; i++));do

    if (( (i-16) % width == 0 )); then
        echo
    fi
    printf "\033[38;5;${i}m%3d\033[0m " "$i"
done

echo
echo
echo "To set one of the following background colors use '\033[48;5;<NUM>m'"
echo
for (( i=0; i<256; i++));do

    if (( (i-16) % width == 0 )); then
        echo
    fi
    printf "\033[48;5;${i}m%3d\033[0m " "$i"
done

echo

    ######### ansi-colors256 ######### END
}
function __complete-ansi-colors256() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-colors256 -- ${BASH_FUNK_PREFIX:--}ansi-colors256

function -ansi-reset() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ansi-reset() {
    local __arg __optionWithValue __params=() __in_subshell __in_pipe __fn=${FUNCNAME[0]/__impl/} _help _selftest
    [ -p /dev/stdout ] && __in_pipe=1 || true
    [ -t 1 ] || __in_subshell=1
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]..."
                echo
                echo "Prints an ANSI escape sequence that reset all ANSI attributes."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### ansi-reset ######### START

echo -ne "\033[0m"

    ######### ansi-reset ######### END
}
function __complete-ansi-reset() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-reset -- ${BASH_FUNK_PREFIX:--}ansi-reset

function -ansi-ul() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [TEXT]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ansi-ul() {
    local __arg __optionWithValue __params=() __in_subshell __in_pipe __fn=${FUNCNAME[0]/__impl/} _on _off _help _selftest _TEXT
    [ -p /dev/stdout ] && __in_pipe=1 || true
    [ -t 1 ] || __in_subshell=1
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [TEXT]"
                echo
                echo "Sets underlined mode or prints the given text underlined."
                echo
                echo "Parameters:"
                echo -e "  \033[1mTEXT\033[22m "
                echo "      The text to print underlined."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --off\033[22m "
                echo "        Print the ANSI escape sequence that disables sets underlined attribute."
                echo -e "\033[1m    --on\033[22m "
                echo "        Print the ANSI escape sequence that enables sets underlined attribute."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --on)
                _on=1
            ;;

            --off)
                _off=1
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_TEXT && ${#__params[@]} > 0 ]]; then
            _TEXT=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### ansi-ul ######### START

if [[ $_TEXT ]]; then
    echo -ne "\033[4m$_TEXT\033[24m"
fi

if [[ $_on ]]; then
    echo -ne "\033[4m"
elif [[ $_off ]]; then
    echo -ne "\033[24m"
fi

    ######### ansi-ul ######### END
}
function __complete-ansi-ul() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --on --off --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-ul -- ${BASH_FUNK_PREFIX:--}ansi-ul

function -test-ansi() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-test-ansi() {
    local __arg __optionWithValue __params=() __in_subshell __in_pipe __fn=${FUNCNAME[0]/__impl/} _help _selftest
    [ -p /dev/stdout ] && __in_pipe=1 || true
    [ -t 1 ] || __in_subshell=1
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]..."
                echo
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### test-ansi ######### START

${BASH_FUNK_PREFIX:--}ansi-bold --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-codes --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-colors-supported --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-colors16 --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-colors256 --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-reset --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-ul --selftest && echo || return 1

    ######### test-ansi ######### END
}
function __complete-test-ansi() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-ansi -- ${BASH_FUNK_PREFIX:--}test-ansi


function -help-ansi() {
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ansi-bold [TEXT]\033[0m  -  Sets bold mode or prints the given text in bold."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ansi-codes [PREFIX]\033[0m  -  Prints commands to set variables with common ANSI codes. When used with the 'echo' command, the -e option is not required."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ansi-colors-supported [NUM_COLORS]\033[0m  -  Determines if the given number of ANSI colors is supported by the current terminal. If NUM_COLORS is specified, the exit value indicates if the color range is supported. If NUM_COLORS is not specified, the number of supported colors is printed with exit code 0."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ansi-colors16\033[0m  -  Prints a table with 8/16 ANSI colors."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ansi-colors256\033[0m  -  Prints a table with 256 ANSI colors."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ansi-reset\033[0m  -  Prints an ANSI escape sequence that reset all ANSI attributes."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ansi-ul [TEXT]\033[0m  -  Sets underlined mode or prints the given text underlined."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}test-ansi\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."

}
__BASH_FUNK_FUNCS+=( ansi-bold ansi-codes ansi-colors-supported ansi-colors16 ansi-colors256 ansi-reset ansi-ul test-ansi )
