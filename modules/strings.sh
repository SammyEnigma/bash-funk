#!/bin/bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#

function -ascii2hex() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... ASCII_STRING

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _ASCII_STRING
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... ASCII_STRING"
                echo 
                echo "Prints the hexa-decimal representation of the given ASCII string."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mASCII_STRING\e[22m (required)"
                echo "      The ASCII string to convert."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn XYZ\e[22m"
                echo "58595A"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn XYZ\e[22m"
                stdout=$($fn XYZ); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^58595A$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [58595A].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_ASCII_STRING ]]; then
            _ASCII_STRING=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_ASCII_STRING ]]; then
        true
    else
        echo "$fn: Error: Parameter ASCII_STRING must be specified.$hint"; return 1
    fi
    
    
    ######################################################

printf "${_ASCII_STRING}" | xxd -p | tr "[a-z]" "[A-z]"

}
function _-ascii2hex() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-ascii2hex -- ${BASH_FUNK_PREFIX:-}-ascii2hex

function -hex2ascii() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... HEX_STRING

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _HEX_STRING
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... HEX_STRING"
                echo 
                echo "Prints the ASCII representation of the given hexa-decimal string."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mHEX_STRING\e[22m (required)"
                echo "      The hexa-decimal string to convert."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn 58595A\e[22m"
                echo "XYZ"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn 58595A\e[22m"
                stdout=$($fn 58595A); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^XYZ$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [XYZ].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_HEX_STRING ]]; then
            _HEX_STRING=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_HEX_STRING ]]; then
        true
    else
        echo "$fn: Error: Parameter HEX_STRING must be specified.$hint"; return 1
    fi
    
    
    ######################################################

printf "${_HEX_STRING}" | xxd -r -p

}
function _-hex2ascii() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-hex2ascii -- ${BASH_FUNK_PREFIX:-}-hex2ascii

function -normalize-path() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... PATH

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _PATH
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... PATH"
                echo 
                echo "Prints the normalized form of the given file path."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mPATH\e[22m (required)"
                echo "      The path to normalize."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn a/./b/c/d/../e\e[22m"
                echo "a/b/c/e"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn a/./b/c/d/../e\e[22m"
                stdout=$($fn a/./b/c/d/../e); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^a/b/c/e$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [a/b/c/e].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PATH ]]; then
            _PATH=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_PATH ]]; then
        true
    else
        echo "$fn: Error: Parameter PATH must be specified.$hint"; return 1
    fi
    
    
    ######################################################

# Remove all occurrences of "/./"
local normalized=${_PATH//\/.\//\/}

# Remove all occurrences of "dir/.."
while [[ ${normalized} =~ [^\/][^\/]*\/\.\.\/ ]]; do
    normalized=${normalized/${BASH_REMATCH[0]}/}
done
echo $normalized

}
function _-normalize-path() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-normalize-path -- ${BASH_FUNK_PREFIX:-}-normalize-path

function -str-join() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... SEPARATOR [STRING]...

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _SEPARATOR _STRING=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... SEPARATOR [STRING]..."
                echo 
                echo "Prints strings joined with the given separator."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSEPARATOR\e[22m (required)"
                echo "      The separator to join the strings."
                echo -e "  \e[1mSTRING\e[22m (0 or more)"
                echo "      The strings to join."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn , a b c\e[22m"
                echo "a,b,c"
                echo -e "$ \e[1m$fn , a \e[22m"
                echo "a"
                echo -e "$ \e[1m$fn , \e[22m"
                echo 
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn , a b c\e[22m"
                stdout=$($fn , a b c); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^a,b,c$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [a,b,c].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn , a \e[22m"
                stdout=$($fn , a ); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^a$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [a].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn , \e[22m"
                stdout=$($fn , ); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_SEPARATOR ]]; then
            _SEPARATOR=$param
            continue
        fi
        _STRING+=("$param")
        continue
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_SEPARATOR ]]; then
        true
    else
        echo "$fn: Error: Parameter SEPARATOR must be specified.$hint"; return 1
    fi
    if [[ _STRING ]]; then
        true
    fi
    
    
    ######################################################

if [[ ${#_STRING[@]} -lt 1 ]]; then
    return 0;
fi
local firstItem=${_STRING[0]}
if [[ ${#_STRING[@]} -lt 2 ]]; then
    echo $firstItem
    return 0;
fi
local additionalItems=("${_STRING[@]:1}")
printf "%s" "$firstItem${additionalItems[@]/#/$_SEPARATOR}"

}
function _-str-join() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-str-join -- ${BASH_FUNK_PREFIX:-}-str-join

function -str-lower() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... STRING

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _STRING
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... STRING"
                echo 
                echo "Prints the given string in lower cases."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSTRING\e[22m (required)"
                echo "      The string to convert."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn aBcDeF\e[22m"
                echo "abcdef"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn aBcDeF\e[22m"
                stdout=$($fn aBcDeF); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^abcdef$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [abcdef].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_STRING ]]; then
            _STRING=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_STRING ]]; then
        true
    else
        echo "$fn: Error: Parameter STRING must be specified.$hint"; return 1
    fi
    
    
    ######################################################

echo "${_STRING,,}"

}
function _-str-lower() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-str-lower -- ${BASH_FUNK_PREFIX:-}-str-lower

function -str-matches() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... REGEX_PATTERN [STRING]...

Type '$fn --help' for more details."
    local arg optionWithValue params=() _all _help _selftest _verbose _REGEX_PATTERN _STRING=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... REGEX_PATTERN [STRING]..."
                echo 
                echo "Matches the given string(s) against the regex pattern, prints the found matches and returns true if at least one match was found."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mREGEX_PATTERN\e[22m (required)"
                echo "      The regex pattern to match the string(s) against."
                echo -e "  \e[1mSTRING\e[22m (0 or more)"
                echo "      The strings to check."
                echo 
                echo "Options:"
                echo -e "\e[1m-a, --all\e[22m "
                echo "        Specifies that all input strings must match."
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo -e "\e[1m-v, --verbose\e[22m "
                echo "        Prints additional information during command execution."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn A\e[22m"
                echo 
                echo -e "$ \e[1m$fn A A B\e[22m"
                echo "A"
                echo -e "$ \e[1m$fn -v A A B\e[22m"
                echo "match: A
no match: B"
                echo -e "$ \e[1m$fn -a A A B\e[22m"
                echo "A"
                echo -e "$ \e[1m$fn -v -a A A B\e[22m"
                echo "match: A
no match: B"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn A\e[22m"
                stdout=$($fn A); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn A A B\e[22m"
                stdout=$($fn A A B); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^A$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [A].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn -v A A B\e[22m"
                stdout=$($fn -v A A B); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^match: A
no match: B$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [match: A
no match: B].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn -a A A B\e[22m"
                stdout=$($fn -a A A B); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1].$hint"; return 1; fi
                regex="^A$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [A].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn -v -a A A B\e[22m"
                stdout=$($fn -v -a A A B); rc=$?
                echo $stdout
                if [[ $rc != 1 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [1].$hint"; return 1; fi
                regex="^match: A
no match: B$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [match: A
no match: B].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
            --all|-a)
                _all=true
            ;;
    
    
    
            --verbose|-v)
                _verbose=true
            ;;
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_REGEX_PATTERN ]]; then
            _REGEX_PATTERN=$param
            continue
        fi
        _STRING+=("$param")
        continue
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_REGEX_PATTERN ]]; then
        true
    else
        echo "$fn: Error: Parameter REGEX_PATTERN must be specified.$hint"; return 1
    fi
    if [[ _STRING ]]; then
        true
    fi
    
    
    ######################################################

if [[ ! ${_STRING} ]]; then
    return 0
fi

local matchFound=false
local mismatchFound=false
local str
for str in ${_STRING[@]}; do
    if [[ $str =~ $_REGEX_PATTERN ]]; then
        if [[ $_verbose ]]; then
            echo "match: $str"
        else
            echo "$str"
        fi
        matchFound=true
        local i=1
        local n=${#BASH_REMATCH[*]}
        while [[ $i -lt $n ]]
        do
            echo "  capture[$i]: ${BASH_REMATCH[$i]}"
            let i++
        done
    else
        if [[ $_verbose ]]; then
            echo "no match: $str"
        fi
        mismatchFound=true
    fi
    shift
done
if [[ $_all ]]; then
    [[ $mismatchFound == "true" ]] && return 1 || return 0
else
    [[ $matchFound == "true" ]] && return 0 || return 1
fi

}
function _-str-matches() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --all -a --help --selftest --verbose -v "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-str-matches -- ${BASH_FUNK_PREFIX:-}-str-matches

function -str-repeat() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... STRING COUNT

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _STRING _COUNT
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... STRING COUNT"
                echo 
                echo "Prints the given string multiple times."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSTRING\e[22m (required)"
                echo "      The string to repeat."
                echo -e "  \e[1mCOUNT\e[22m (required)"
                echo "      Number of times to repeat the string."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn a 3\e[22m"
                echo "aaa"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn a 3\e[22m"
                stdout=$($fn a 3); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^aaa$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [aaa].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_STRING ]]; then
            _STRING=$param
            continue
        fi
        if [[ ! $_COUNT ]]; then
            _COUNT=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_STRING ]]; then
        true
    else
        echo "$fn: Error: Parameter STRING must be specified.$hint"; return 1
    fi
    if [[ $_COUNT ]]; then
        if [[ ! "$_COUNT" =~ ^-?[0-9]*$ ]]; then echo "$fn: Error: Value '$_COUNT' for parameter COUNT is not a numeric value.$hint"; return 1; fi
        if [[ $_COUNT -lt 1 ]]; then echo "$fn: Error: Value '$_COUNT' for parameter COUNT is too low. Must be >= 1.$hint"; return 1; fi
        true
    else
        echo "$fn: Error: Parameter COUNT must be specified.$hint"; return 1
    fi
    
    
    ######################################################

local spaces="$(printf "%${_COUNT}s" "")"
echo "${spaces// /${_STRING}}"

}
function _-str-repeat() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-str-repeat -- ${BASH_FUNK_PREFIX:-}-str-repeat

function -str-trim() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... STRING

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _STRING
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... STRING"
                echo 
                echo "Prints the given string without leading and trailing spaces."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSTRING\e[22m (required)"
                echo "      The string to trim."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn \"  abc  \"\e[22m"
                echo "abc"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn "  abc  "\e[22m"
                stdout=$($fn "  abc  "); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^abc$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [abc].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_STRING ]]; then
            _STRING=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_STRING ]]; then
        true
    else
        echo "$fn: Error: Parameter STRING must be specified.$hint"; return 1
    fi
    
    
    ######################################################

echo ${_STRING}

}
function _-str-trim() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-str-trim -- ${BASH_FUNK_PREFIX:-}-str-trim

function -str-upper() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... STRING

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _STRING
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... STRING"
                echo 
                echo "Prints the given string in upper cases."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSTRING\e[22m (required)"
                echo "      The string to convert."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn aBcDeF\e[22m"
                echo "ABCDEF"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn aBcDeF\e[22m"
                stdout=$($fn aBcDeF); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^ABCDEF$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [ABCDEF].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_STRING ]]; then
            _STRING=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_STRING ]]; then
        true
    else
        echo "$fn: Error: Parameter STRING must be specified.$hint"; return 1
    fi
    
    
    ######################################################

echo "${1^^}"

}
function _-str-upper() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-str-upper -- ${BASH_FUNK_PREFIX:-}-str-upper

function -strip-ansi() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... [STRING]...

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _STRING=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... [STRING]..."
                echo 
                echo "Removes any ANSI escape sequences from the given string or from stdin."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSTRING\e[22m (0 or more)"
                echo "      The strings to strip."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn $(echo -e '\e[4mThis is underlined\e[24m')\e[22m"
                echo "This is underlined"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn $(echo -e '\e[4mThis is underlined\e[24m')\e[22m"
                stdout=$($fn $(echo -e '\e[4mThis is underlined\e[24m')); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^This is underlined$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [This is underlined].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ${#_STRING[@]} -lt 0 ]]; then
            _STRING+=("$param")
            continue
        fi
        local leftoverParams=$((${#params[@]} - 0 - ${#_STRING[@]}))
        if [[ $leftoverParams -gt 0 ]]; then
            _STRING+=("$param")
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ _STRING ]]; then
        true
    fi
    
    
    ######################################################

local ansiColors="([0-9]{1,2}(;[0-9]{1,2})?(;[0-9]{1,2})?)?[m|K]"
local ansiCursors1="[0-9]+[A-D]" # cursor up/down/right/left
local ansiCursors2="[su]" # save/restore cursor position
local ansiPattern="\x1B\[((${ansiColors})|(${ansiCursors1})|(${ansiCursors2}))"
if [[ ${_STRING} ]]; then
    echo "${_STRING[@]}" | sed -u -r "s/${ansiPattern}//g"
else
    sed -u -r "s/${ansiPattern}//g"
fi

}
function _-strip-ansi() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-strip-ansi -- ${BASH_FUNK_PREFIX:-}-strip-ansi

function -substr-after() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... SEARCH_IN SEARCH_FOR

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _SEARCH_IN _SEARCH_FOR
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... SEARCH_IN SEARCH_FOR"
                echo 
                echo "Prints the substring after the first occurrence of SEARCH_FOR."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSEARCH_IN\e[22m (required)"
                echo "      The string to search."
                echo -e "  \e[1mSEARCH_FOR\e[22m (required)"
                echo "      The separator."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn 00aa11aa22 aa\e[22m"
                echo "11aa22"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn 00aa11aa22 aa\e[22m"
                stdout=$($fn 00aa11aa22 aa); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^11aa22$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [11aa22].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_SEARCH_IN ]]; then
            _SEARCH_IN=$param
            continue
        fi
        if [[ ! $_SEARCH_FOR ]]; then
            _SEARCH_FOR=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_SEARCH_IN ]]; then
        true
    else
        echo "$fn: Error: Parameter SEARCH_IN must be specified.$hint"; return 1
    fi
    if [[ $_SEARCH_FOR ]]; then
        true
    else
        echo "$fn: Error: Parameter SEARCH_FOR must be specified.$hint"; return 1
    fi
    
    
    ######################################################

echo ${_SEARCH_IN#*${_SEARCH_FOR}}

}
function _-substr-after() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-substr-after -- ${BASH_FUNK_PREFIX:-}-substr-after

function -substr-after-last() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... SEARCH_IN SEARCH_FOR

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _SEARCH_IN _SEARCH_FOR
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... SEARCH_IN SEARCH_FOR"
                echo 
                echo "Prints the substring after the last occurrence of SEARCH_FOR."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSEARCH_IN\e[22m (required)"
                echo "      The string to search."
                echo -e "  \e[1mSEARCH_FOR\e[22m (required)"
                echo "      The separator."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn 00aa11aa22 aa\e[22m"
                echo "22"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn 00aa11aa22 aa\e[22m"
                stdout=$($fn 00aa11aa22 aa); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^22$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [22].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_SEARCH_IN ]]; then
            _SEARCH_IN=$param
            continue
        fi
        if [[ ! $_SEARCH_FOR ]]; then
            _SEARCH_FOR=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_SEARCH_IN ]]; then
        true
    else
        echo "$fn: Error: Parameter SEARCH_IN must be specified.$hint"; return 1
    fi
    if [[ $_SEARCH_FOR ]]; then
        true
    else
        echo "$fn: Error: Parameter SEARCH_FOR must be specified.$hint"; return 1
    fi
    
    
    ######################################################

echo "${_SEARCH_IN#${_SEARCH_IN%${_SEARCH_FOR}*}${_SEARCH_FOR}}"

}
function _-substr-after-last() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-substr-after-last -- ${BASH_FUNK_PREFIX:-}-substr-after-last

function -substr-before() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... SEARCH_IN SEARCH_FOR

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _SEARCH_IN _SEARCH_FOR
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... SEARCH_IN SEARCH_FOR"
                echo 
                echo "Prints the substring before the first occurrence of SEARCH_FOR."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSEARCH_IN\e[22m (required)"
                echo "      The string to search."
                echo -e "  \e[1mSEARCH_FOR\e[22m (required)"
                echo "      The separator."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn 00aa11aa22 aa\e[22m"
                echo "00"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn 00aa11aa22 aa\e[22m"
                stdout=$($fn 00aa11aa22 aa); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^00$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [00].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_SEARCH_IN ]]; then
            _SEARCH_IN=$param
            continue
        fi
        if [[ ! $_SEARCH_FOR ]]; then
            _SEARCH_FOR=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_SEARCH_IN ]]; then
        true
    else
        echo "$fn: Error: Parameter SEARCH_IN must be specified.$hint"; return 1
    fi
    if [[ $_SEARCH_FOR ]]; then
        true
    else
        echo "$fn: Error: Parameter SEARCH_FOR must be specified.$hint"; return 1
    fi
    
    
    ######################################################

echo "${_SEARCH_IN%%${_SEARCH_FOR}*}"

}
function _-substr-before() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-substr-before -- ${BASH_FUNK_PREFIX:-}-substr-before

function -substr-before-last() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... SEARCH_IN SEARCH_FOR

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _SEARCH_IN _SEARCH_FOR
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... SEARCH_IN SEARCH_FOR"
                echo 
                echo "Prints the substring before the last occurrence of SEARCH_FOR."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSEARCH_IN\e[22m (required)"
                echo "      The string to search."
                echo -e "  \e[1mSEARCH_FOR\e[22m (required)"
                echo "      The separator."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn 00aa11aa00 aa\e[22m"
                echo "00aa11"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn 00aa11aa00 aa\e[22m"
                stdout=$($fn 00aa11aa00 aa); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^00aa11$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [00aa11].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_SEARCH_IN ]]; then
            _SEARCH_IN=$param
            continue
        fi
        if [[ ! $_SEARCH_FOR ]]; then
            _SEARCH_FOR=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_SEARCH_IN ]]; then
        true
    else
        echo "$fn: Error: Parameter SEARCH_IN must be specified.$hint"; return 1
    fi
    if [[ $_SEARCH_FOR ]]; then
        true
    else
        echo "$fn: Error: Parameter SEARCH_FOR must be specified.$hint"; return 1
    fi
    
    
    ######################################################

echo "${_SEARCH_IN%${_SEARCH_FOR}*}"

}
function _-substr-before-last() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-substr-before-last -- ${BASH_FUNK_PREFIX:-}-substr-before-last

function -substr-between() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... SEARCH_IN PREFIX SUFFIX

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _SEARCH_IN _PREFIX _SUFFIX
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... SEARCH_IN PREFIX SUFFIX"
                echo 
                echo "Prints the substring between PREFIX and SUFFIX."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSEARCH_IN\e[22m (required)"
                echo "      The string to search."
                echo -e "  \e[1mPREFIX\e[22m (required)"
                echo "      The start separator."
                echo -e "  \e[1mSUFFIX\e[22m (required)"
                echo "      The end separator."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m$fn 00aa11aa22aa00 aa aa\e[22m"
                echo "11"
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m$fn 00aa11aa22aa00 aa aa\e[22m"
                stdout=$($fn 00aa11aa22aa00 aa aa); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^11$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [11].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_SEARCH_IN ]]; then
            _SEARCH_IN=$param
            continue
        fi
        if [[ ! $_PREFIX ]]; then
            _PREFIX=$param
            continue
        fi
        if [[ ! $_SUFFIX ]]; then
            _SUFFIX=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_SEARCH_IN ]]; then
        true
    else
        echo "$fn: Error: Parameter SEARCH_IN must be specified.$hint"; return 1
    fi
    if [[ $_PREFIX ]]; then
        true
    else
        echo "$fn: Error: Parameter PREFIX must be specified.$hint"; return 1
    fi
    if [[ $_SUFFIX ]]; then
        true
    else
        echo "$fn: Error: Parameter SUFFIX must be specified.$hint"; return 1
    fi
    
    
    ######################################################

local withoutPrefix="${_SEARCH_IN#*${_PREFIX}}"
echo "${withoutPrefix%%${_SUFFIX}*}"

}
function _-substr-between() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-substr-between -- ${BASH_FUNK_PREFIX:-}-substr-between

function -test-strings() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]...

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]..."
                echo 
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \e[1m$fn --help\e[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo "--> OK"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

${BASH_FUNK_PREFIX:-}-ascii2hex --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-hex2ascii --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-normalize-path --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-str-join --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-str-lower --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-str-matches --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-str-repeat --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-str-trim --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-str-upper --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-strip-ansi --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-substr-after --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-substr-after-last --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-substr-before --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-substr-before-last --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-substr-between --selftest && echo || return 1
}
function _-test-strings() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-strings -- ${BASH_FUNK_PREFIX:-}-test-strings

function -help-strings() {

    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-ascii2hex ASCII_STRING\e[0m  -  Prints the hexa-decimal representation of the given ASCII string."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-hex2ascii HEX_STRING\e[0m  -  Prints the ASCII representation of the given hexa-decimal string."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-normalize-path PATH\e[0m  -  Prints the normalized form of the given file path."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-str-join SEPARATOR [STRING]...\e[0m  -  Prints strings joined with the given separator."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-str-lower STRING\e[0m  -  Prints the given string in lower cases."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-str-matches REGEX_PATTERN [STRING]...\e[0m  -  Matches the given string(s) against the regex pattern, prints the found matches and returns true if at least one match was found."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-str-repeat STRING COUNT\e[0m  -  Prints the given string multiple times."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-str-trim STRING\e[0m  -  Prints the given string without leading and trailing spaces."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-str-upper STRING\e[0m  -  Prints the given string in upper cases."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-strip-ansi [STRING]...\e[0m  -  Removes any ANSI escape sequences from the given string or from stdin."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-substr-after SEARCH_IN SEARCH_FOR\e[0m  -  Prints the substring after the first occurrence of SEARCH_FOR."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-substr-after-last SEARCH_IN SEARCH_FOR\e[0m  -  Prints the substring after the last occurrence of SEARCH_FOR."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-substr-before SEARCH_IN SEARCH_FOR\e[0m  -  Prints the substring before the first occurrence of SEARCH_FOR."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-substr-before-last SEARCH_IN SEARCH_FOR\e[0m  -  Prints the substring before the last occurrence of SEARCH_FOR."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-substr-between SEARCH_IN PREFIX SUFFIX\e[0m  -  Prints the substring between PREFIX and SUFFIX."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-strings\e[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."

}

