#!/bin/bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
    
function -abspath() {

    local arg optionWithValue params=() _help _selftest _PATH
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [PATH]"
                echo 
                echo "Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mPATH\e[22m "
                echo "      The path to normalize."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PATH && ${#params[@]} > 0 ]]; then
            _PATH=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_PATH ]]; then
        true
    fi
    
    
    ######################################################


# use realpath if available
if hash realpath &> /dev/null; then
    realpath -m ${_PATH:-.}

# use python as last resort
else
    python -c "import os
print os.path.abspath('${_PATH:-.}')"
fi


}
function _-abspath() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-abspath -- ${BASH_FUNK_PREFIX:-}-abspath
    
function -df() {

    local arg optionWithValue params=() _help _selftest _PATH=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [PATH]..."
                echo 
                echo "Prints free disk space information in tabular form."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mPATH\e[22m (0 or more)"
                echo "      The path to check."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ${#_PATH[@]} -lt 0 ]]; then
            _PATH+=("$param")
            continue
        fi
        local leftoverParams=$((${#params[@]} - 0 - ${#_PATH[@]}))
        if [[ $leftoverParams -gt 0 ]]; then
            _PATH+=("$param")
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ _PATH ]]; then
        true
    fi
    
    
    ######################################################

local firstColMaxWidth=$(( $(for line in $(command df -h | awk '{print $1}'); do echo ${#line}; done | sort -nr | sed q) + 2 ))
df -h ${_PATH[@]} | sed -e :a -e '$!N;s/\n / /;ta' -e 'P;D' | awk '{printf "%-'${firstColMaxWidth}'s %-6s %-6s %-6s %-4s %s %s\n", $1,$2,$3,$4,$5,$6,$7}'

}
function _-df() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-df -- ${BASH_FUNK_PREFIX:-}-df
    
function -du() {

    local arg optionWithValue params=() _help _selftest _PATH=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [PATH]..."
                echo 
                echo "Prints disk usage information."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mPATH\e[22m (0 or more)"
                echo "      The path to check."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ${#_PATH[@]} -lt 0 ]]; then
            _PATH+=("$param")
            continue
        fi
        local leftoverParams=$((${#params[@]} - 0 - ${#_PATH[@]}))
        if [[ $leftoverParams -gt 0 ]]; then
            _PATH+=("$param")
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ _PATH ]]; then
        true
    fi
    
    
    ######################################################

du -s -h ${_PATH[@]}

}
function _-du() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-du -- ${BASH_FUNK_PREFIX:-}-du
    
function -findfiles() {

    local arg optionWithValue params=() _lines _unpack _maxdepth _maxdepth_value _mindepth _mindepth_value _name _name_value _help _selftest _verbose _START_PATH _SEARCH_STRING
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [START_PATH] SEARCH_STRING"
                echo 
                echo "Recursively finds all files containing the given string and displays their path."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mSTART_PATH\e[22m "
                echo "      The path where to search."
                echo -e "  \e[1mSEARCH_STRING\e[22m (required)"
                echo "      The string to search."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m-l, --lines\e[22m "
                echo "        Show matching lines of the files that contain the given string."
                echo -e "\e[1m    --maxdepth levels\e[22m "
                echo "        The maximum number of levels to descend into the directory tree below the starting-point."
                echo -e "\e[1m    --mindepth levels\e[22m "
                echo "        The level of directory tree below the starting-point where to start the search."
                echo -e "\e[1m    --name pattern\e[22m "
                echo "        Name pattern."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo -e "\e[1m-u, --unpack\e[22m "
                echo "        Unpack supported archives (.zip, .jar, .war, .ear)."
                echo -e "\e[1m-v, --verbose\e[22m "
                echo "        Prints additional information during command execution."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
            --lines|-l)
                _lines=true
            ;;
    
            --unpack|-u)
                _unpack=true
            ;;
    
            --maxdepth)
                _maxdepth=true
                _maxdepth_value=
                optionWithValue=--maxdepth
            ;;
    
            --mindepth)
                _mindepth=true
                _mindepth_value=
                optionWithValue=--mindepth
            ;;
    
            --name)
                _name=true
                _name_value=
                optionWithValue=--name
            ;;
    
    
    
            --verbose|-v)
                _verbose=true
            ;;
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    --maxdepth)
                        _maxdepth_value=$arg
                        optionWithValue=
                      ;;
                    --mindepth)
                        _mindepth_value=$arg
                        optionWithValue=
                      ;;
                    --name)
                        _name_value=$arg
                        optionWithValue=
                      ;;
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_START_PATH && ${#params[@]} > 1 ]]; then
            _START_PATH=$param
            continue
        fi
        if [[ ! $_SEARCH_STRING ]]; then
            _SEARCH_STRING=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    if [[ $_maxdepth ]]; then
        if [[ ! $_maxdepth_value ]]; then echo "Error: Value levels for option --maxdepth must be specified."; return 1; fi
        if [[ ! "$_maxdepth_value" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_maxdepth_value' for option --maxdepth is not a numeric value."; return 1; fi
        true
    fi
    if [[ $_mindepth ]]; then
        if [[ ! $_mindepth_value ]]; then echo "Error: Value levels for option --mindepth must be specified."; return 1; fi
        if [[ ! "$_mindepth_value" =~ ^-?[0-9]*$ ]]; then echo "Error: Value '$_mindepth_value' for option --mindepth is not a numeric value."; return 1; fi
        true
    fi
    if [[ $_name ]]; then
        if [[ ! $_name_value ]]; then echo "Error: Value pattern for option --name must be specified."; return 1; fi
        true
    fi
    
    if [[ $_START_PATH ]]; then
        true
    fi
    if [[ $_SEARCH_STRING ]]; then
        true
    else
        echo "Error: Parameter SEARCH_STRING must be specified."; return 1
    fi
    
    
    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    ######################################################


local _START_PATH=${_START_PATH:-.}

if [[ ! -e $_START_PATH ]]; then
    echo "Error: Path [$_START_PATH] does not exist."
    return 1
fi

if [[ ! -r $_START_PATH ]]; then
    echo "Error: Path [$_START_PATH] is not readable by user '$USER'."
    return 1
fi

if [[ $_lines ]]; then
    local grepCmd="grep -n"
else
    local grepCmd="grep -l"
fi

local findOpts="-type f"
if [[ $_name ]]; then
    findOpts="$findOpts -name $_name_value"
fi
if [[ $_maxdepth ]]; then
    findOpts="$findOpts -maxdepth $_maxdepth_value"
fi
if [[ $_mindepth ]]; then
    findOpts="$findOpts -mindepth $_mindepth_value"
fi

# turn off verbose if part of pipe or subshell
[[ $_in_pipe || $_in_subshell ]] && _verbose=

if [[ $_verbose ]]; then
    if hash tput &>/dev/null; then
        cols=$(tput cols)
    else
        cols=$(stty size| cut -d' ' -f 2)
    fi

    find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
        local message="Scanning $file ..."

        echo -en "\e[s${message:0:$cols}"
        if [[ $_unpack && ( $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ) ]]; then
            if unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
                echo -e "\e[u\e[K$file" || echo -e "$file"
            else
                echo -en "\e[u\e[K"
            fi
        else
            if LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
                echo -e "\e[u\e[K$file" || echo -e "$file"
            else
                echo -en "\e[u\e[K"
            fi
        fi
    done

else

    if [[ $_unpack ]]; then

        find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
            if [[ $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ]]; then
                unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null || true
            else
                LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
            fi
        done

    else

        # to avoid "xargs: environment is too large for exec" on cygwin
        local xargsWorks=1
        if [[ $OSTYPE == cygwin ]]; then
            if ! echo whoami | xargs &> /dev/null; then
                local xargsWorks=
            fi
        fi

        if [[ $xargsWorks ]]; then
            find "$_START_PATH:-" $findOpts -print0 | LC_ALL=C xargs -r -0 -P2 $grepCmd "$_SEARCH_STRING" 2>/dev/null
        else
            find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
                LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
            done
        fi
    fi
fi


}
function _-findfiles() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --lines -l --unpack -u --maxdepth --mindepth --name --help --selftest --verbose -v "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-findfiles -- ${BASH_FUNK_PREFIX:-}-findfiles
    
function -ll() {

    local arg optionWithValue params=() _help _selftest _PATH=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [PATH]..."
                echo 
                echo "Alternative version of 'ls -lt' hat prints directories and symbolic links to directories before files."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mPATH\e[22m (0 or more)"
                echo "      The path to list."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ${#_PATH[@]} -lt 0 ]]; then
            _PATH+=("$param")
            continue
        fi
        local leftoverParams=$((${#params[@]} - 0 - ${#_PATH[@]}))
        if [[ $leftoverParams -gt 0 ]]; then
            _PATH+=("$param")
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ _PATH ]]; then
        true
    fi
    
    
    ######################################################

command ls -lAph -I lost+found --color=always ${_PATH[@]} | awk '
    BEGIN { dirs = ""; files = "" }
    /^total/ { total = $0 }                 # capture total line
    /^d/ { dirs = dirs "\n" $0 };           # capture directories
    /^l.*[/]$/ { dirs = dirs "\n" $0 };     # capture symlinks to directories
    /^-/ { files = files "\n" $0 };         # capture files
    /^l.*[^/]$/ { files = files "\n" $0 };  # capture symlinks to files
    END { print total dirs files }'

}
function _-ll() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-ll -- ${BASH_FUNK_PREFIX:-}-ll
    
function -modified() {

    local arg optionWithValue params=() _help _selftest _PATH
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [PATH]"
                echo 
                echo "Prints the modification timestamp of the given file or directory."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mPATH\e[22m "
                echo "      The file or directory to check."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PATH && ${#params[@]} > 0 ]]; then
            _PATH=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_PATH ]]; then
        true
    fi
    
    
    ######################################################


local _PATH=${_PATH:-.}

if [[ ! -e $_PATH ]]; then
    echo "Error: Path [$_PATH] does not exist."
    return 1
fi

if [[ ! -f $_PATH ]]; then
    echo "Error: Path [$_PATH] is not readable by user '$USER'."
    return 1
fi

# use stat if available
if hash stat &> /dev/null; then
    echo $(stat -c %y ${_PATH:-.})

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use File::stat;
print stat("${_PATH:-.}")->mtime, "\n"
EOF

# use python as last resort
else
    python -c "import os, pwd
print int(os.path.getmtime('${_PATH:-.}'))"
fi


}
function _-modified() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-modified -- ${BASH_FUNK_PREFIX:-}-modified
    
function -owner() {

    local arg optionWithValue params=() _help _selftest _PATH
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [PATH]"
                echo 
                echo "Prints the owner of the given file or directory."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mPATH\e[22m "
                echo "      The file or directory to check."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PATH && ${#params[@]} > 0 ]]; then
            _PATH=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_PATH ]]; then
        true
    fi
    
    
    ######################################################


local _PATH=${_PATH:-.}

if [[ ! -e $_PATH ]]; then
    echo "Error: Path [$_PATH] does not exist."
    return 1
fi

if [[ ! -f $_PATH ]]; then
    echo "Error: Path [$_PATH] is not readable by user '$USER'."
    return 1
fi

# use stat if available
if hash stat &> /dev/null; then
    echo $(stat -c %U ${_PATH:-.})

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use File::stat;
print getpwuid(stat("${_PATH:-.}")->uid), "\n"
EOF

# use python as last resort
else
    python -c "import os, pwd
print pwd.getpwuid(os.stat('${_PATH:-.}').st_uid).pw_name"
fi


}
function _-owner() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-owner -- ${BASH_FUNK_PREFIX:-}-owner
    
function -realpath() {

    local arg optionWithValue params=() _help _selftest _PATH
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... [PATH]"
                echo 
                echo "Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mPATH\e[22m "
                echo "      The path to normalize."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PATH && ${#params[@]} > 0 ]]; then
            _PATH=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_PATH ]]; then
        true
    fi
    
    
    ######################################################


# use readlink if available
if hash readlink &> /dev/null; then
    readlink -m ${_PATH:-.}

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use Cwd 'abs_path';
print abs_path('${_PATH:-.}'), "\n"
EOF

# use python as last resort
else
    python -c "import os
print os.path.realpath('${_PATH:-.}')"
fi


}
function _-realpath() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-realpath -- ${BASH_FUNK_PREFIX:-}-realpath
    
function -sudo-append() {

    local arg optionWithValue params=() _help _selftest _FILE_PATH _CONTENT
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... FILE_PATH CONTENT"
                echo 
                echo "Creates a file with the given content."
                echo 
                echo "Requirements:"
                echo "  + Sudo 'tee --append' is required."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mFILE_PATH\e[22m (required)"
                echo "      The path to the file to write."
                echo -e "  \e[1mCONTENT\e[22m (required)"
                echo "      The content to append to the file."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} /tmp/testfile.cfg 'foo=bar'\e[22m"
                echo "Appending to [/tmp/testfile.cfg]..."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} /tmp/testfile.cfg 'foo=bar'\e[22m"
                stdout=$(${FUNCNAME[0]} /tmp/testfile.cfg 'foo=bar'); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^Appending to [/tmp/testfile.cfg]...$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Appending to [/tmp/testfile.cfg]...]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_FILE_PATH ]]; then
            _FILE_PATH=$param
            continue
        fi
        if [[ ! $_CONTENT ]]; then
            _CONTENT=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_FILE_PATH ]]; then
        true
    else
        echo "Error: Parameter FILE_PATH must be specified."; return 1
    fi
    if [[ $_CONTENT ]]; then
        true
    else
        echo "Error: Parameter CONTENT must be specified."; return 1
    fi
    
    if ! hash "sudo" &> /dev/null; then echo "Error: Required command 'sudo' not found on this system."; return 1; fi
    if ! sudo -l -- permission &> /dev/null; then echo "Error: User misses required sudo permission for 'tee --append'"; return 1; fi
    
    ######################################################

echo "Appending to [$_FILE_PATH]..."
echo "$_CONTENT" | sudo tee --append "$_FILE_PATH" > /dev/null

}
function _-sudo-append() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-sudo-append -- ${BASH_FUNK_PREFIX:-}-sudo-append
    
function -sudo-write() {

    local arg optionWithValue params=() _help _selftest _FILE_PATH _OWNER _CONTENT
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]... FILE_PATH OWNER CONTENT"
                echo 
                echo "Creates a file with the given content."
                echo 
                echo "Requirements:"
                echo "  + Sudo 'sh -c' is required."
                echo "  + Sudo 'sh chown' is required."
                echo 
                echo "Parameters:"
                echo -e "  \e[1mFILE_PATH\e[22m (required)"
                echo "      The path to the file to write."
                echo -e "  \e[1mOWNER\e[22m (required)"
                echo "      The owner and group to set."
                echo -e "  \e[1mCONTENT\e[22m (required)"
                echo "      The content to write."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \e[1m${FUNCNAME[0]} /tmp/testfile.cfg $USER:$USER 'foo=bar'\e[22m"
                echo "Writing [/tmp/testfile.cfg]..."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo -e "$ \e[1m${FUNCNAME[0]} /tmp/testfile.cfg $USER:$USER 'foo=bar'\e[22m"
                stdout=$(${FUNCNAME[0]} /tmp/testfile.cfg $USER:$USER 'foo=bar'); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                regex="^Writing [/tmp/testfile.cfg]...$"
                if [[ ! "$stdout" =~ $regex ]]; then echo "--> FAILED - stdout [$stdout] does not match required pattern [Writing [/tmp/testfile.cfg]...]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_FILE_PATH ]]; then
            _FILE_PATH=$param
            continue
        fi
        if [[ ! $_OWNER ]]; then
            _OWNER=$param
            continue
        fi
        if [[ ! $_CONTENT ]]; then
            _CONTENT=$param
            continue
        fi
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_FILE_PATH ]]; then
        true
    else
        echo "Error: Parameter FILE_PATH must be specified."; return 1
    fi
    if [[ $_OWNER ]]; then
        true
    else
        echo "Error: Parameter OWNER must be specified."; return 1
    fi
    if [[ $_CONTENT ]]; then
        true
    else
        echo "Error: Parameter CONTENT must be specified."; return 1
    fi
    
    if ! hash "sudo" &> /dev/null; then echo "Error: Required command 'sudo' not found on this system."; return 1; fi
    if ! sudo -l -- permission &> /dev/null; then echo "Error: User misses required sudo permission for 'sh -c'"; return 1; fi
    if ! hash "sudo" &> /dev/null; then echo "Error: Required command 'sudo' not found on this system."; return 1; fi
    if ! sudo -l -- permission &> /dev/null; then echo "Error: User misses required sudo permission for 'sh chown'"; return 1; fi
    
    ######################################################

echo "Writing [$_FILE_PATH]..."
sudo sh -c "echo '$_CONTENT' > $_FILE_PATH" && sudo chown $_OWNER "$_FILE_PATH"

}
function _-sudo-write() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-sudo-write -- ${BASH_FUNK_PREFIX:-}-sudo-write
    
function -test-filesystem() {

    local arg optionWithValue params=() _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: ${FUNCNAME[0]} [OPTION]..."
                echo 
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo 
                echo "Options:"
                echo -e "\e[1m    --help\e[22m "
                echo "        Prints this help."
                echo -e "\e[1m    --selftest\e[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [${FUNCNAME[0]}]..."
                echo -e "$ \e[1m${FUNCNAME[0]} --help\e[22m"
                local regex stdout rc
                stdout=$(${FUNCNAME[0]} --help); rc=$?
                if [[ $rc != 0 ]]; then echo "--> FAILED - exit code [$rc] instead of expected [0]."; return 1; fi
                echo "--> OK"
                echo "Testing function [${FUNCNAME[0]}]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "${FUNCNAME[0]}: invalid option: '$arg'"
                echo Type \'${FUNCNAME[0]} --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "${FUNCNAME[0]}: too many parameters: '$param'"
        echo Type \'${FUNCNAME[0]} --help\' for usage.
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

${BASH_FUNK_PREFIX:-}-abspath --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-df --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-du --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-findfiles --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-ll --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-modified --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-owner --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-realpath --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-sudo-append --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-sudo-write --selftest && echo || return 1
}
function _-test-filesystem() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-filesystem -- ${BASH_FUNK_PREFIX:-}-test-filesystem

function -help-filesystem() {

    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-abspath [PATH]\e[0m  -  Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-df [PATH]...\e[0m  -  Prints free disk space information in tabular form."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-du [PATH]...\e[0m  -  Prints disk usage information."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-findfiles [START_PATH] SEARCH_STRING\e[0m  -  Recursively finds all files containing the given string and displays their path."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-ll [PATH]...\e[0m  -  Alternative version of 'ls -lt' hat prints directories and symbolic links to directories before files."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-modified [PATH]\e[0m  -  Prints the modification timestamp of the given file or directory."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-owner [PATH]\e[0m  -  Prints the owner of the given file or directory."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-realpath [PATH]\e[0m  -  Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-sudo-append FILE_PATH CONTENT\e[0m  -  Creates a file with the given content."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-sudo-write FILE_PATH OWNER CONTENT\e[0m  -  Creates a file with the given content."
    echo -e "\e[1m${BASH_FUNK_PREFIX:-}-test-filesystem\e[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."

}


alias ll="${BASH_FUNK_PREFIX:-}-ll"

