#!/usr/bin/env bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
function -abspath() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-abspath() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]"
                echo
                echo "Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (default: '.')"
                echo "      The path to normalize."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
            _PATH=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_PATH ]]; then _PATH="."; fi

    ######################################################

# use realpath if available
if hash realpath &> /dev/null; then
    realpath -m $_PATH

# use python as last resort
else
    python -c "import os
print os.path.abspath('$_PATH')"
fi
}
function __complete-abspath() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}abspath -- ${BASH_FUNK_PREFIX:--}abspath

function -count-words() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... FILE WORD1[WORD]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-count-words() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... FILE WORD1[WORD]..."
                echo
                echo "Counts the number of occurences of the word(s) in the given file."
                echo
                echo "Parameters:"
                echo -e "  \033[1mFILE\033[22m (required)"
                echo "      The file to analyze."
                echo -e "  \033[1mWORD\033[22m (1 or more required)"
                echo "      The word to count."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo -e "\033[1m-s, --sort MODE\033[22m (one of: [count,word])"
                echo "        Specifies how to sort the output."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --sort|-s)
                local _sort=
                __optionWithValue=sort
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    sort)
                        _sort=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_FILE ]]; then
            _FILE=$__param
            continue
        fi
        _WORD+=("$__param")
        continue
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if declare -p _sort &>/dev/null; then
        if [[ ! $_sort ]]; then echo "$__fn: Error: Value MODE for option --sort must be specified."; return 64; fi
        declare -A __allowed=( [count]=1 [word]=1 )
        if [[ ! ${__allowed[$_sort]} ]]; then echo "$__fn: Error: Value '$_sort' for option --sort is not one of the allowed values [count,word]."; return 64; fi
        true
    fi

    if [[ $_FILE ]]; then
        true
    else
        echo "$__fn: Error: Parameter FILE must be specified."; return 64
    fi
    if [[ ${#_WORD[@]} -lt 1 ]]; then echo "$__fn: Error: For parameter WORD 1 value(s) must be specified. Found: ${#_WORD[@]}."; return 64; fi

    ######################################################
if [[ ! -e "$_FILE" ]]; then
    echo "Error: File [$_FILE] does not exist."
    return 1
fi

if [[ ! -r "$_FILE" ]]; then
    echo "Error: File [$_FILE] is not readable by user '$USER'."
    return 1
fi

if [[ ! -f "$_FILE" ]]; then
    echo "Error: Path [$_FILE] does not point to a file."
    return 1
fi

local sedCmds grepCmds
for word in "${_WORD[@]}"; do
    sedCmds="s/$word/\n$word\n/g; $sedCmds"
    grepCmds="$grepCmds -e $word"
done

if [[ $_sort == "count" ]]; then
    sed "$sedCmds" "$_FILE" | grep $grepCmds | sort | uniq -c | sort -r
else
    sed "$sedCmds" "$_FILE" | grep $grepCmds | sort | uniq -c
fi
}
function __complete-count-words() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --sort -s --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}count-words -- ${BASH_FUNK_PREFIX:--}count-words

function -du() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-du() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]..."
                echo
                echo "Prints disk usage information."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m "
                echo "      The path to check."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ${#_PATH[@]} -lt 0 ]]; then
            _PATH+=("$__param")
            continue
        fi
        local __leftoverParams=$(( ${#__params[@]} - 0 - ${#_PATH[@]} ))
        if [[ $__leftoverParams -gt 0 ]]; then
            _PATH+=("$__param")
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######################################################
[[ ! $_PATH ]] && _PATH=(.) || true

du -s -h "${_PATH[@]}"
}
function __complete-du() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}du -- ${BASH_FUNK_PREFIX:--}du

function -extract() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... ARCHIVE [TO_DIR]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-extract() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... ARCHIVE [TO_DIR]"
                echo
                echo "Extracts the given archive using the compatible extractor."
                echo
                echo "Parameters:"
                echo -e "  \033[1mARCHIVE\033[22m (required)"
                echo "      The archive to extract."
                echo -e "  \033[1mTO_DIR\033[22m "
                echo "      The target folder."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_ARCHIVE ]]; then
            _ARCHIVE=$__param
            continue
        fi
        if [[ ! $_TO_DIR ]]; then
            _TO_DIR=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_ARCHIVE ]]; then
        true
    else
        echo "$__fn: Error: Parameter ARCHIVE must be specified."; return 64
    fi

    ######################################################
if [[ ! -e "$_ARCHIVE" ]]; then
    echo "Error: File [$_ARCHIVE] does not exist."
    return 1
fi

if [[ ! -r "$_ARCHIVE" ]]; then
    echo "Error: File [$_ARCHIVE] is not readable by user '$USER'."
    return 1
fi

if [[ ! -f "$_ARCHIVE" ]]; then
    echo "Error: Path [$_ARCHIVE] does not point to a file."
    return 1
fi

if [[ $_TO_DIR ]]; then
    local origPWD="$(pwd)"
    mkdir "$_TO_DIR"
    cd "$_TO_DIR"
fi

if [[ ! -w "$(pwd)" ]]; then
    echo "Error: Path [$_pwd] is not writeable."
    return 1
fi

local tmpDir=$(mktemp -d -p "$(pwd)")

case "$_FILE" in
    *.bz2)            bunzip2    "$_ARCHIVE" ;;
    *.gz)             gunzip     "$_ARCHIVE" ;;
    *.rar)            unrar x    "$_ARCHIVE" ;;
    *.tar)            tar xvf    "$_ARCHIVE" ;;
    *.tbz2|*.tar.bz2) tar xvjf   "$_ARCHIVE" ;;
    *.tgz|*.tar.gz)   tar xvzf   "$_ARCHIVE" ;;
    *.zip)            unzip      "$_ARCHIVE" ;;
    *.Z)              uncompress "$_ARCHIVE" ;;
    *.7z)             7z x       "$_ARCHIVE" ;;
    *) echo "Error: Unsupported archive format '$_ARCHIVE'"; return 1 ;;
esac

if [[ $_TO_DIR ]]; then
    cd "$origPWD"
fi
}
function __complete-extract() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}extract -- ${BASH_FUNK_PREFIX:--}extract

function -findfiles() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [START_PATH] SEARCH_STRING"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-findfiles() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [START_PATH] SEARCH_STRING"
                echo
                echo "Recursively finds all files containing the given string and displays their path."
                echo
                echo "Parameters:"
                echo -e "  \033[1mSTART_PATH\033[22m (default: '.')"
                echo "      The path where to search."
                echo -e "  \033[1mSEARCH_STRING\033[22m (required)"
                echo "      The string to search."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m-l, --lines\033[22m "
                echo "        Show matching lines of the files that contain the given string."
                echo -e "\033[1m    --maxdepth levels\033[22m (integer: ?-?)"
                echo "        The maximum number of levels to descend into the directory tree below the starting-point."
                echo -e "\033[1m    --mindepth levels\033[22m (integer: ?-?)"
                echo "        The level of directory tree below the starting-point where to start the search."
                echo -e "\033[1m    --name pattern\033[22m "
                echo "        Name pattern."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo -e "\033[1m-u, --unpack\033[22m "
                echo "        Unpack supported archives (.zip, .jar, .war, .ear)."
                echo -e "\033[1m-v, --verbose\033[22m "
                echo "        Prints additional information during command execution."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --lines|-l)
                local _lines=1
            ;;

            --unpack|-u)
                local _unpack=1
            ;;

            --maxdepth)
                local _maxdepth=
                __optionWithValue=maxdepth
            ;;

            --mindepth)
                local _mindepth=
                __optionWithValue=mindepth
            ;;

            --name)
                local _name=
                __optionWithValue=name
            ;;

            --verbose|-v)
                local _verbose=1
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    maxdepth)
                        _maxdepth=$__arg
                        __optionWithValue=
                      ;;
                    mindepth)
                        _mindepth=$__arg
                        __optionWithValue=
                      ;;
                    name)
                        _name=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_START_PATH && ${#__params[@]} > 1 ]]; then
            _START_PATH=$__param
            continue
        fi
        if [[ ! $_SEARCH_STRING ]]; then
            _SEARCH_STRING=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_START_PATH ]]; then _START_PATH="."; fi
    if declare -p _maxdepth &>/dev/null; then
        if [[ ! $_maxdepth ]]; then echo "$__fn: Error: Value levels for option --maxdepth must be specified."; return 64; fi
        if [[ ! "$_maxdepth" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_maxdepth' for option --maxdepth is not a numeric value."; return 64; fi
        true
    fi
    if declare -p _mindepth &>/dev/null; then
        if [[ ! $_mindepth ]]; then echo "$__fn: Error: Value levels for option --mindepth must be specified."; return 64; fi
        if [[ ! "$_mindepth" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_mindepth' for option --mindepth is not a numeric value."; return 64; fi
        true
    fi
    if declare -p _name &>/dev/null; then
        if [[ ! $_name ]]; then echo "$__fn: Error: Value pattern for option --name must be specified."; return 64; fi
        true
    fi

    if [[ $_SEARCH_STRING ]]; then
        true
    else
        echo "$__fn: Error: Parameter SEARCH_STRING must be specified."; return 64
    fi

    ######################################################
if [[ ! -e "$_START_PATH" ]]; then
    echo "Error: Path [$_START_PATH] does not exist."
    return 1
fi

if [[ ! -r "$_START_PATH" ]]; then
    echo "Error: Path [$_START_PATH] is not readable by user '$USER'."
    return 1
fi

if [[ $_lines ]]; then
    local grepCmd="grep -n"
else
    local grepCmd="grep -l"
fi

local findOpts="-type f"
if [[ $_name ]]; then
    findOpts="$findOpts -name $_name"
fi
if [[ $_maxdepth ]]; then
    findOpts="$findOpts -maxdepth $_maxdepth"
fi
if [[ $_mindepth ]]; then
    findOpts="$findOpts -mindepth $_mindepth"
fi

# turn off verbose if part of pipe or subshell
[[ $__in_pipe || $__in_subshell ]] && _verbose=

if [[ $_verbose ]]; then
    if hash tput &>/dev/null; then
        cols=$(tput cols)
    else
        cols=$(stty size| cut -d' ' -f 2)
    fi

    find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
        local message="Scanning $file ..."

        echo -en "\033[s${message:0:$cols}"
        if [[ $_unpack && ( $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ) ]]; then
            if unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
                echo -e "\033[u\033[K$file" || echo -e "$file"
            else
                echo -en "\033[u\033[K"
            fi
        else
            if LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
                echo -e "\033[u\033[K$file" || echo -e "$file"
            else
                echo -en "\033[u\033[K"
            fi
        fi
    done

else

    if [[ $_unpack ]]; then

        find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
            if [[ $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ]]; then
                unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null || true
            else
                LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
            fi
        done

    else

        # to avoid "xargs: environment is too large for exec" on cygwin
        local xargsWorks=1
        if [[ $OSTYPE == cygwin ]]; then
            if ! echo whoami | xargs &> /dev/null; then
                local xargsWorks=
            fi
        fi

        if [[ $xargsWorks ]]; then
            find "$_START_PATH" $findOpts -print0 | LC_ALL=C xargs -r -0 -P2 $grepCmd "$_SEARCH_STRING" 2>/dev/null
        else
            find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
                LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
            done
        fi
    fi
fi
}
function __complete-findfiles() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --lines -l --unpack -u --maxdepth --mindepth --name --help --selftest --verbose -v "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}findfiles -- ${BASH_FUNK_PREFIX:--}findfiles

function -ll() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ll() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]..."
                echo
                echo "Alternative version of 'ls -lt' hat prints directories and symbolic links to directories before files."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m "
                echo "      The path to list."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ${#_PATH[@]} -lt 0 ]]; then
            _PATH+=("$__param")
            continue
        fi
        local __leftoverParams=$(( ${#__params[@]} - 0 - ${#_PATH[@]} ))
        if [[ $__leftoverParams -gt 0 ]]; then
            _PATH+=("$__param")
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######################################################
[[ ! $_PATH ]] && _PATH=(.) || true

if ls --help | grep -- --group-directories-first >/dev/null; then
    command ls -lAph -I lost+found --color=always --group-directories-first "${_PATH[@]}"
else
    command ls -lAph -I lost+found --color=always "${_PATH[@]}" | awk '
        BEGIN { dirs = ""; files = "" }
        /^total/ { total = $0 }                 # capture total line
        /^d/ { dirs = dirs "\n" $0 };           # capture directories
        /^l.*[/]$/ { dirs = dirs "\n" $0 };     # capture symlinks to directories
        /^-/ { files = files "\n" $0 };         # capture files
        /^l.*[^/]$/ { files = files "\n" $0 };  # capture symlinks to files
        END { print total dirs files }'
fi
}
function __complete-ll() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ll -- ${BASH_FUNK_PREFIX:--}ll

function -mkcd() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... PATH"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-mkcd() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... PATH"
                echo
                echo "Creates a directory and changes into it."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (required)"
                echo "      The path to create."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m-m, --mode MODE\033[22m (pattern: \"[0-7]{3}\")"
                echo "        The file mode for the new directory."
                echo -e "\033[1m-p, --parents\033[22m "
                echo "        Automatically create missing parent directories."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo -e "\033[1m-v, --verbose\033[22m "
                echo "        Prints additional information during command execution."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --mode|-m)
                local _mode=
                __optionWithValue=mode
            ;;

            --parents|-p)
                local _parents=1
            ;;

            --verbose|-v)
                local _verbose=1
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    mode)
                        _mode=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PATH ]]; then
            _PATH=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if declare -p _mode &>/dev/null; then
        if [[ ! $_mode ]]; then echo "$__fn: Error: Value MODE for option --mode must be specified."; return 64; fi
        local __regex="^[0-7]{3}$"
        if [[ ! "$_mode" =~ $__regex ]]; then echo "$__fn: Error: Value '$_mode' for option --mode does not match required pattern '[0-7]{3}'."; return 64; fi
        true
    fi

    if [[ $_PATH ]]; then
        true
    else
        echo "$__fn: Error: Parameter PATH must be specified."; return 64
    fi

    ######################################################
local mkdirOpts

[[ $_mode    ]] && mkdirOpts="$mkdirOpts -m $_mode" || true
[[ $_parents ]] && mkdirOpts="$mkdirOpts -p" || true
[[ $_verbose ]] && mkdirOpts="$mkdirOpts -v" || true

mkdir "$_PATH" && cd "$_PATH"
}
function __complete-mkcd() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --mode -m --parents -p --help --selftest --verbose -v "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}mkcd -- ${BASH_FUNK_PREFIX:--}mkcd

function -modified() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-modified() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]"
                echo
                echo "Prints the modification timestamp of the given file or directory."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (default: '.')"
                echo "      The file or directory to check."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
            _PATH=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_PATH ]]; then _PATH="."; fi

    ######################################################
if [[ ! -e "$_PATH" ]]; then
    echo "Error: Path [$_PATH] does not exist."
    return 1
fi

if [[ ! -r "$_PATH" ]]; then
    echo "Error: Path [$_PATH] is not readable by user '$USER'."
    return 1
fi

# use stat if available
if hash stat &> /dev/null; then
    echo $(stat -c %y "$_PATH"})

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use File::stat;
print stat("$_PATH")->mtime, "\n"
EOF

# use python as last resort
else
    python -c "import os, pwd
print int(os.path.getmtime('$_PATH'))"
fi
}
function __complete-modified() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}modified -- ${BASH_FUNK_PREFIX:--}modified

function -owner() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-owner() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]"
                echo
                echo "Prints the owner of the given file or directory."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (default: '.')"
                echo "      The file or directory to check."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
            _PATH=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_PATH ]]; then _PATH="."; fi

    ######################################################
if [[ ! -e "$_PATH" ]]; then
    echo "Error: Path [$_PATH] does not exist."
    return 1
fi

if [[ ! -r "$_PATH" ]]; then
    echo "Error: Path [$_PATH] is not readable by user '$USER'."
    return 1
fi

# use stat if available
if hash stat &> /dev/null; then
    echo $(stat -c %U "$_PATH")

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use File::stat;
print getpwuid(stat("$_PATH")->uid), "\n"
EOF

# use python as last resort
else
    python -c "import os, pwd
print pwd.getpwuid(os.stat('$_PATH').st_uid).pw_name"
fi
}
function __complete-owner() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}owner -- ${BASH_FUNK_PREFIX:--}owner

function -realpath() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-realpath() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]"
                echo
                echo "Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (default: '.')"
                echo "      The path to normalize."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
            _PATH=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_PATH ]]; then _PATH="."; fi

    ######################################################
# use readlink if available
if hash readlink &> /dev/null; then
    readlink -m "$_PATH"

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use Cwd 'abs_path';
print abs_path('$_PATH'), "\n"
EOF

# use python as last resort
else
    python -c "import os
print os.path.realpath('$_PATH')"
fi
}
function __complete-realpath() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}realpath -- ${BASH_FUNK_PREFIX:--}realpath

function -sudo-append() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... FILE_PATH CONTENT"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-sudo-append() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... FILE_PATH CONTENT"
                echo
                echo "Creates a file with the given content."
                echo
                echo "Requirements:"
                echo "  + Sudo 'tee --append' is required."
                echo
                echo "Parameters:"
                echo -e "  \033[1mFILE_PATH\033[22m (required)"
                echo "      The path to the file to write."
                echo -e "  \033[1mCONTENT\033[22m (required)"
                echo "      The content to append to the file."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                echo "Examples:"
                echo -e "$ \033[1m$__fn /tmp/testfile.cfg 'foo=bar'\033[22m"
                echo -e "Appending to \[/tmp/testfile.cfg\]..."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo -e "$ \033[1m$__fn /tmp/testfile.cfg 'foo=bar'\033[22m"
                __stdout=$($__fn /tmp/testfile.cfg 'foo=bar'); __rc=$?
                echo $__stdout
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^Appending to \[/tmp/testfile.cfg\]...$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> [31mFAILED[0m - stdout [$__stdout] does not match required pattern [Appending to \[/tmp/testfile.cfg\]...]."; return 64; fi
                echo "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_FILE_PATH ]]; then
            _FILE_PATH=$__param
            continue
        fi
        if [[ ! $_CONTENT ]]; then
            _CONTENT=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_FILE_PATH ]]; then
        true
    else
        echo "$__fn: Error: Parameter FILE_PATH must be specified."; return 64
    fi
    if [[ $_CONTENT ]]; then
        true
    else
        echo "$__fn: Error: Parameter CONTENT must be specified."; return 64
    fi

    if ! hash "sudo" &> /dev/null; then echo "$__fn: Error: Required command 'sudo' not found on this system."; return 64; fi
    if ! sudo -l -- tee --append &> /dev/null; then echo "$__fn: Error: User $USER misses required sudo permission for 'tee --append'"; return 64; fi

    ######################################################
echo "Appending to [$_FILE_PATH]..."
echo "$_CONTENT" | sudo tee --append "$_FILE_PATH" > /dev/null
}
function __complete-sudo-append() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}sudo-append -- ${BASH_FUNK_PREFIX:--}sudo-append

function -sudo-write() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... FILE_PATH OWNER CONTENT"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-sudo-write() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... FILE_PATH OWNER CONTENT"
                echo
                echo "Creates a file with the given content."
                echo
                echo "Requirements:"
                echo "  + Sudo 'sh -c' is required."
                echo "  + Sudo 'sh chown' is required."
                echo
                echo "Parameters:"
                echo -e "  \033[1mFILE_PATH\033[22m (required)"
                echo "      The path to the file to write."
                echo -e "  \033[1mOWNER\033[22m (required)"
                echo "      The owner and group to set."
                echo -e "  \033[1mCONTENT\033[22m (required)"
                echo "      The content to write."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                echo "Examples:"
                echo -e "$ \033[1m$__fn /tmp/testfile.cfg $USER:$USER 'foo=bar'\033[22m"
                echo -e "Writing \[/tmp/testfile.cfg\]..."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo -e "$ \033[1m$__fn /tmp/testfile.cfg $USER:$USER 'foo=bar'\033[22m"
                __stdout=$($__fn /tmp/testfile.cfg $USER:$USER 'foo=bar'); __rc=$?
                echo $__stdout
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^Writing \[/tmp/testfile.cfg\]...$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> [31mFAILED[0m - stdout [$__stdout] does not match required pattern [Writing \[/tmp/testfile.cfg\]...]."; return 64; fi
                echo "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_FILE_PATH ]]; then
            _FILE_PATH=$__param
            continue
        fi
        if [[ ! $_OWNER ]]; then
            _OWNER=$__param
            continue
        fi
        if [[ ! $_CONTENT ]]; then
            _CONTENT=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_FILE_PATH ]]; then
        true
    else
        echo "$__fn: Error: Parameter FILE_PATH must be specified."; return 64
    fi
    if [[ $_OWNER ]]; then
        true
    else
        echo "$__fn: Error: Parameter OWNER must be specified."; return 64
    fi
    if [[ $_CONTENT ]]; then
        true
    else
        echo "$__fn: Error: Parameter CONTENT must be specified."; return 64
    fi

    if ! hash "sudo" &> /dev/null; then echo "$__fn: Error: Required command 'sudo' not found on this system."; return 64; fi
    if ! sudo -l -- sh -c &> /dev/null; then echo "$__fn: Error: User $USER misses required sudo permission for 'sh -c'"; return 64; fi
    if ! hash "sudo" &> /dev/null; then echo "$__fn: Error: Required command 'sudo' not found on this system."; return 64; fi
    if ! sudo -l -- sh chown &> /dev/null; then echo "$__fn: Error: User $USER misses required sudo permission for 'sh chown'"; return 64; fi

    ######################################################
echo "Writing [$_FILE_PATH]..."
sudo sh -c "echo '$_CONTENT' > '$_FILE_PATH'" && sudo chown "$_OWNER" "$_FILE_PATH"
}
function __complete-sudo-write() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}sudo-write -- ${BASH_FUNK_PREFIX:--}sudo-write

function -test-filesystem() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-test-filesystem() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]..."
                echo
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######################################################
${BASH_FUNK_PREFIX:--}abspath --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}count-words --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}du --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}extract --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}findfiles --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ll --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}mkcd --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}modified --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}owner --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}realpath --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}sudo-append --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}sudo-write --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}up --selftest && echo || return 1
}
function __complete-test-filesystem() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-filesystem -- ${BASH_FUNK_PREFIX:--}test-filesystem

function -up() {
    local opts=""
    local opt
    for opt in a e u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -e
    set -o pipefail

    local __fn=${FUNCNAME[0]}
    __impl$__fn "$@" && local rc=0 || local rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [LEVEL_OR_DIRECTORY_NAME]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-up() {
    [ -p /dev/stdout ] && local -r __in_pipe=1 || true
    [ -t 1 ] || local  -r __in_subshell=1
    local -r __fn=${FUNCNAME[0]/__impl/}
    local __arg __optionWithValue __params=()
    for __arg in "$@"; do
        case $__arg in

            --help)
                echo "Usage: $__fn [OPTION]... [LEVEL_OR_DIRECTORY_NAME]"
                echo
                echo "Navigates to the given level or directory up in the directory tree. Bash completion will auto-complete the names of the parent directories."
                echo
                echo "Parameters:"
                echo -e "  \033[1mLEVEL_OR_DIRECTORY_NAME\033[22m (default: '..')"
                echo "      The level to navigate up in the directory structure. Numeric value or the name of the directory to go back to."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                __stdout=$($__fn --help); __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_LEVEL_OR_DIRECTORY_NAME && ${#__params[@]} > 0 ]]; then
            _LEVEL_OR_DIRECTORY_NAME=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_LEVEL_OR_DIRECTORY_NAME ]]; then _LEVEL_OR_DIRECTORY_NAME=".."; fi

    ######################################################
if [[ $_LEVEL_OR_DIRECTORY_NAME == ".." ]]; then
    cd ..
    return 0
fi

if [[ $_LEVEL_OR_DIRECTORY_NAME =~ ^[0-9]+$ ]]; then
    local cdArgs
    for (( i = 0; i < _LEVEL_OR_DIRECTORY_NAME; i++ )); do
        cdArgs="../$cdArgs"
    done
    cd $cdArgs
else
    local path=$(pwd)
    cd "${path%${_LEVEL_OR_DIRECTORY_NAME}*}${_LEVEL_OR_DIRECTORY_NAME}"
fi
}
function __complete-up() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        local path="$(pwd)"; COMPREPLY=( $(IFS=$'\n' compgen -o default -W "$( echo -e "${path////\n}" | sed 's/^/\x27/; s/$/\x27/' )" -- "$currentWord") )
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}up -- ${BASH_FUNK_PREFIX:--}up


function -help-filesystem() {
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}abspath [PATH]\033[0m  -  Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}count-words FILE WORD1[WORD]...\033[0m  -  Counts the number of occurences of the word(s) in the given file."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}du [PATH]...\033[0m  -  Prints disk usage information."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}extract ARCHIVE [TO_DIR]\033[0m  -  Extracts the given archive using the compatible extractor."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}findfiles [START_PATH] SEARCH_STRING\033[0m  -  Recursively finds all files containing the given string and displays their path."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ll [PATH]...\033[0m  -  Alternative version of 'ls -lt' hat prints directories and symbolic links to directories before files."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}mkcd PATH\033[0m  -  Creates a directory and changes into it."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}modified [PATH]\033[0m  -  Prints the modification timestamp of the given file or directory."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}owner [PATH]\033[0m  -  Prints the owner of the given file or directory."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}realpath [PATH]\033[0m  -  Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}sudo-append FILE_PATH CONTENT\033[0m  -  Creates a file with the given content."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}sudo-write FILE_PATH OWNER CONTENT\033[0m  -  Creates a file with the given content."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}test-filesystem\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}up [LEVEL_OR_DIRECTORY_NAME]\033[0m  -  Navigates to the given level or directory up in the directory tree. Bash completion will auto-complete the names of the parent directories."

}
__BASH_FUNK_FUNCS+=( abspath count-words du extract findfiles ll mkcd modified owner realpath sudo-append sudo-write test-filesystem up )

alias l="ll"
alias ll="${BASH_FUNK_PREFIX:--}ll"
alias ..="${BASH_FUNK_PREFIX:--}up"
alias ...="command cd ../.."

if [[ $OSTYPE == "cygwin" ]]; then
    for drive in {a..z}; do
        if [[ -e /cygdrive/${drive} ]]; then
            alias "${drive}:"="cd /cygdrive/${drive}"
            alias "${drive^^}:"="cd /cygdrive/${drive}"
        fi
    done
fi
