#!/usr/bin/env bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#

function -abspath() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... [PATH]

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _PATH
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... [PATH]"
                echo 
                echo "Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m "
                echo "      The path to normalize."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PATH && ${#params[@]} > 0 ]]; then
            _PATH=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_PATH ]]; then
        true
    fi
    
    
    ######################################################


# use realpath if available
if hash realpath &> /dev/null; then
    realpath -m ${_PATH:-.}

# use python as last resort
else
    python -c "import os
print os.path.abspath('${_PATH:-.}')"
fi


}
function _-abspath() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-abspath -- ${BASH_FUNK_PREFIX:-}-abspath

function -count-words() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... FILE WORD1 [WORD]...

Type '$fn --help' for more details."
    local arg optionWithValue params=() _sort _sort_value _help _selftest _FILE _WORD=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... FILE WORD1 [WORD]..."
                echo 
                echo "Counts the number of occurences of the word(s) in the given file."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mFILE\033[22m (required)"
                echo "      The file to analyze."
                echo -e "  \033[1mWORD\033[22m (1 or more required)"
                echo "      The word to count."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo -e "\033[1m-s, --sort MODE\033[22m (one of: [count,word])"
                echo "        Specifies how to sort the output."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
            --sort|-s)
                _sort=true
                _sort_value=
                optionWithValue=--sort
            ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    --sort)
                        _sort_value=$arg
                        optionWithValue=
                      ;;
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_FILE ]]; then
            _FILE=$param
            continue
        fi
        _WORD+=("$param")
        continue
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    if [[ $_sort ]]; then
        if [[ ! $_sort_value ]]; then echo "$fn: Error: Value MODE for option --sort must be specified.$hint"; return 1; fi
        declare -A allowed=( [count]=1 [word]=1 )
        if [[ ! ${allowed[$_sort_value]} ]]; then echo "$fn: Error: Value '$_sort_value' for option --sort is not one of the allowed values [count,word].$hint"; return 1; fi
        unset allowed
        true
    fi
    
    if [[ $_FILE ]]; then
        true
    else
        echo "$fn: Error: Parameter FILE must be specified.$hint"; return 1
    fi
    if [[ _WORD ]]; then
        if [[ ${#_WORD[@]} -lt 1 ]]; then echo "$fn: Error: For parameter WORD 1 value(s) must be specified. Found: ${#_WORD[@]}.$hint"; return 1; fi
        true
    else
        echo "$fn: Error: Parameter WORD must be specified."; return 1
    fi
    
    
    ######################################################

if [[ ! -e "$_FILE" ]]; then
    echo "Error: File [$_FILE] does not exist."
    return 1
fi

if [[ ! -r "$_FILE" ]]; then
    echo "Error: File [$_FILE] is not readable by user '$USER'."
    return 1
fi

if [[ ! -f "$_FILE" ]]; then
    echo "Error: Path [$_FILE] does not point to a file."
    return 1
fi

local sedCmds grepCmds
for word in "${_WORD[@]}"; do
    sedCmds="s/$word/\n$word\n/g; $sedCmds"
    grepCmds="$grepCmds -e $word"
done

if [[ $_sort_value == "count" ]]; then
    sed "$sedCmds" "$_FILE" | grep $grepCmds | sort | uniq -c | sort -r
else
    sed "$sedCmds" "$_FILE" | grep $grepCmds | sort | uniq -c
fi

}
function _-count-words() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --sort -s --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-count-words -- ${BASH_FUNK_PREFIX:-}-count-words

function -du() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]...  [PATH]...

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _PATH=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]...  [PATH]..."
                echo 
                echo "Prints disk usage information."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (0 or more)"
                echo "      The path to check."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ${#_PATH[@]} -lt 0 ]]; then
            _PATH+=("$param")
            continue
        fi
        local leftoverParams=$((${#params[@]} - 0 - ${#_PATH[@]}))
        if [[ $leftoverParams -gt 0 ]]; then
            _PATH+=("$param")
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ _PATH ]]; then
        true
    fi
    
    
    ######################################################

du -s -h ${_PATH[@]}

}
function _-du() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-du -- ${BASH_FUNK_PREFIX:-}-du

function -extract() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... FILE

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _FILE
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... FILE"
                echo 
                echo "Extracts the given archive using the compatible extractor."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mFILE\033[22m (required)"
                echo "      The archive to extract."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_FILE ]]; then
            _FILE=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_FILE ]]; then
        true
    else
        echo "$fn: Error: Parameter FILE must be specified.$hint"; return 1
    fi
    
    
    ######################################################

if [[ ! -e "$_FILE" ]]; then
    echo "Error: File [$_FILE] does not exist."
    return 1
fi

if [[ ! -r "$_FILE" ]]; then
    echo "Error: File [$_FILE] is not readable by user '$USER'."
    return 1
fi

if [[ ! -f "$_FILE" ]]; then
    echo "Error: Path [$_FILE] does not point to a file."
    return 1
fi

case "$_FILE" in
    *.bz2)            bunzip2    "$_FILE" ;;
    *.gz)             gunzip     "$_FILE" ;;
    *.rar)            unrar x    "$_FILE" ;;
    *.tar)            tar xvf    "$_FILE" ;;
    *.tbz2|*.tar.bz2) tar xvjf   "$_FILE" ;;
    *.tgz|*.tar.gz)   tar xvzf   "$_FILE" ;;
    *.zip)            unzip      "$_FILE" ;;
    *.Z)              uncompress "$_FILE" ;;
    *.7z)             7z x       "$_FILE" ;;
    *) echo "Error: Unsupported archive format '$_FILE'"; return 1 ;;
esac


}
function _-extract() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-extract -- ${BASH_FUNK_PREFIX:-}-extract

function -findfiles() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... [START_PATH] SEARCH_STRING

Type '$fn --help' for more details."
    local arg optionWithValue params=() _lines _unpack _maxdepth _maxdepth_value _mindepth _mindepth_value _name _name_value _help _selftest _verbose _START_PATH _SEARCH_STRING
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... [START_PATH] SEARCH_STRING"
                echo 
                echo "Recursively finds all files containing the given string and displays their path."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mSTART_PATH\033[22m "
                echo "      The path where to search."
                echo -e "  \033[1mSEARCH_STRING\033[22m (required)"
                echo "      The string to search."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m-l, --lines\033[22m "
                echo "        Show matching lines of the files that contain the given string."
                echo -e "\033[1m    --maxdepth levels\033[22m (integer: ?-?)"
                echo "        The maximum number of levels to descend into the directory tree below the starting-point."
                echo -e "\033[1m    --mindepth levels\033[22m (integer: ?-?)"
                echo "        The level of directory tree below the starting-point where to start the search."
                echo -e "\033[1m    --name pattern\033[22m "
                echo "        Name pattern."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo -e "\033[1m-u, --unpack\033[22m "
                echo "        Unpack supported archives (.zip, .jar, .war, .ear)."
                echo -e "\033[1m-v, --verbose\033[22m "
                echo "        Prints additional information during command execution."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
            --lines|-l)
                _lines=true
            ;;
    
            --unpack|-u)
                _unpack=true
            ;;
    
            --maxdepth)
                _maxdepth=true
                _maxdepth_value=
                optionWithValue=--maxdepth
            ;;
    
            --mindepth)
                _mindepth=true
                _mindepth_value=
                optionWithValue=--mindepth
            ;;
    
            --name)
                _name=true
                _name_value=
                optionWithValue=--name
            ;;
    
    
    
            --verbose|-v)
                _verbose=true
            ;;
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    --maxdepth)
                        _maxdepth_value=$arg
                        optionWithValue=
                      ;;
                    --mindepth)
                        _mindepth_value=$arg
                        optionWithValue=
                      ;;
                    --name)
                        _name_value=$arg
                        optionWithValue=
                      ;;
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_START_PATH && ${#params[@]} > 1 ]]; then
            _START_PATH=$param
            continue
        fi
        if [[ ! $_SEARCH_STRING ]]; then
            _SEARCH_STRING=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    if [[ $_maxdepth ]]; then
        if [[ ! $_maxdepth_value ]]; then echo "$fn: Error: Value levels for option --maxdepth must be specified.$hint"; return 1; fi
        if [[ ! "$_maxdepth_value" =~ ^-?[0-9]*$ ]]; then echo "$fn: Error: Value '$_maxdepth_value' for option --maxdepth is not a numeric value.$hint"; return 1; fi
        true
    fi
    if [[ $_mindepth ]]; then
        if [[ ! $_mindepth_value ]]; then echo "$fn: Error: Value levels for option --mindepth must be specified.$hint"; return 1; fi
        if [[ ! "$_mindepth_value" =~ ^-?[0-9]*$ ]]; then echo "$fn: Error: Value '$_mindepth_value' for option --mindepth is not a numeric value.$hint"; return 1; fi
        true
    fi
    if [[ $_name ]]; then
        if [[ ! $_name_value ]]; then echo "$fn: Error: Value pattern for option --name must be specified.$hint"; return 1; fi
        true
    fi
    
    if [[ $_START_PATH ]]; then
        true
    fi
    if [[ $_SEARCH_STRING ]]; then
        true
    else
        echo "$fn: Error: Parameter SEARCH_STRING must be specified.$hint"; return 1
    fi
    
    
    ######################################################


local _START_PATH=${_START_PATH:-.}

if [[ ! -e "$_START_PATH" ]]; then
    echo "Error: Path [$_START_PATH] does not exist."
    return 1
fi

if [[ ! -r "$_START_PATH" ]]; then
    echo "Error: Path [$_START_PATH] is not readable by user '$USER'."
    return 1
fi

if [[ $_lines ]]; then
    local grepCmd="grep -n"
else
    local grepCmd="grep -l"
fi

local findOpts="-type f"
if [[ $_name ]]; then
    findOpts="$findOpts -name $_name_value"
fi
if [[ $_maxdepth ]]; then
    findOpts="$findOpts -maxdepth $_maxdepth_value"
fi
if [[ $_mindepth ]]; then
    findOpts="$findOpts -mindepth $_mindepth_value"
fi

# turn off verbose if part of pipe or subshell
[[ $_in_pipe || $_in_subshell ]] && _verbose=

if [[ $_verbose ]]; then
    if hash tput &>/dev/null; then
        cols=$(tput cols)
    else
        cols=$(stty size| cut -d' ' -f 2)
    fi

    find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
        local message="Scanning $file ..."

        echo -en "\033[s${message:0:$cols}"
        if [[ $_unpack && ( $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ) ]]; then
            if unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
                echo -e "\033[u\033[K$file" || echo -e "$file"
            else
                echo -en "\033[u\033[K"
            fi
        else
            if LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
                echo -e "\033[u\033[K$file" || echo -e "$file"
            else
                echo -en "\033[u\033[K"
            fi
        fi
    done

else

    if [[ $_unpack ]]; then

        find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
            if [[ $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ]]; then
                unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null || true
            else
                LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
            fi
        done

    else

        # to avoid "xargs: environment is too large for exec" on cygwin
        local xargsWorks=1
        if [[ $OSTYPE == cygwin ]]; then
            if ! echo whoami | xargs &> /dev/null; then
                local xargsWorks=
            fi
        fi

        if [[ $xargsWorks ]]; then
            find "$_START_PATH" $findOpts -print0 | LC_ALL=C xargs -r -0 -P2 $grepCmd "$_SEARCH_STRING" 2>/dev/null
        else
            find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
                LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
            done
        fi
    fi
fi


}
function _-findfiles() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --lines -l --unpack -u --maxdepth --mindepth --name --help --selftest --verbose -v "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-findfiles -- ${BASH_FUNK_PREFIX:-}-findfiles

function -ll() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]...  [PATH]...

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _PATH=()
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]...  [PATH]..."
                echo 
                echo "Alternative version of 'ls -lt' hat prints directories and symbolic links to directories before files."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (0 or more)"
                echo "      The path to list."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ${#_PATH[@]} -lt 0 ]]; then
            _PATH+=("$param")
            continue
        fi
        local leftoverParams=$((${#params[@]} - 0 - ${#_PATH[@]}))
        if [[ $leftoverParams -gt 0 ]]; then
            _PATH+=("$param")
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ _PATH ]]; then
        true
    fi
    
    
    ######################################################


if ls --help | grep -- --group-directories-first >/dev/null; then
    command ls -lAph -I lost+found --color=always --group-directories-first ${_PATH[@]}   
else
    command ls -lAph -I lost+found --color=always ${_PATH[@]} | awk '
        BEGIN { dirs = ""; files = "" }
        /^total/ { total = $0 }                 # capture total line
        /^d/ { dirs = dirs "\n" $0 };           # capture directories
        /^l.*[/]$/ { dirs = dirs "\n" $0 };     # capture symlinks to directories
        /^-/ { files = files "\n" $0 };         # capture files
        /^l.*[^/]$/ { files = files "\n" $0 };  # capture symlinks to files
        END { print total dirs files }'
fi

}
function _-ll() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-ll -- ${BASH_FUNK_PREFIX:-}-ll

function -mkcd() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... PATH

Type '$fn --help' for more details."
    local arg optionWithValue params=() _mode _mode_value _parents _help _selftest _verbose _PATH
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... PATH"
                echo 
                echo "Creates a directory and changes into it."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (required)"
                echo "      The path to create."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m-m, --mode MODE\033[22m (pattern: \"[0-7]{3}\")"
                echo "        The file mode for the new directory."
                echo -e "\033[1m-p, --parents\033[22m "
                echo "        Automatically create missing parent directories."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo -e "\033[1m-v, --verbose\033[22m "
                echo "        Prints additional information during command execution."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
            --mode|-m)
                _mode=true
                _mode_value=
                optionWithValue=--mode
            ;;
    
            --parents|-p)
                _parents=true
            ;;
    
    
    
            --verbose|-v)
                _verbose=true
            ;;
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    --mode)
                        _mode_value=$arg
                        optionWithValue=
                      ;;
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PATH ]]; then
            _PATH=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    if [[ $_mode ]]; then
        if [[ ! $_mode_value ]]; then echo "$fn: Error: Value MODE for option --mode must be specified.$hint"; return 1; fi
        local regex="^[0-7]{3}$"
        if [[ ! "$_mode_value" =~ $regex ]]; then echo "$fn: Error: Value '$_mode_value' for option --mode does not match required pattern '[0-7]{3}'.$hint"; return 1; fi
        unset regex
        true
    fi
    
    if [[ $_PATH ]]; then
        true
    else
        echo "$fn: Error: Parameter PATH must be specified.$hint"; return 1
    fi
    
    
    ######################################################

local mkdirOpts

[[ $_mode    ]] && mkdirOpts="$mkdirOpts -m $_mode_value" || true
[[ $_parents ]] && mkdirOpts="$mkdirOpts -p" || true
[[ $_verbose ]] && mkdirOpts="$mkdirOpts -v" || true

mkdir "$_PATH" && cd "$_PATH"

}
function _-mkcd() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --mode -m --parents -p --help --selftest --verbose -v "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-mkcd -- ${BASH_FUNK_PREFIX:-}-mkcd

function -modified() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... [PATH]

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _PATH
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... [PATH]"
                echo 
                echo "Prints the modification timestamp of the given file or directory."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m "
                echo "      The file or directory to check."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PATH && ${#params[@]} > 0 ]]; then
            _PATH=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_PATH ]]; then
        true
    fi
    
    
    ######################################################


local _PATH=${_PATH:-.}

if [[ ! -e "$_PATH" ]]; then
    echo "Error: Path [$_PATH] does not exist."
    return 1
fi

if [[ ! -r "$_PATH" ]]; then
    echo "Error: Path [$_PATH] is not readable by user '$USER'."
    return 1
fi

# use stat if available
if hash stat &> /dev/null; then
    echo $(stat -c %y "$_PATH"})

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use File::stat;
print stat("$_PATH")->mtime, "\n"
EOF

# use python as last resort
else
    python -c "import os, pwd
print int(os.path.getmtime('$_PATH'))"
fi


}
function _-modified() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-modified -- ${BASH_FUNK_PREFIX:-}-modified

function -owner() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... [PATH]

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _PATH
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... [PATH]"
                echo 
                echo "Prints the owner of the given file or directory."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m "
                echo "      The file or directory to check."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PATH && ${#params[@]} > 0 ]]; then
            _PATH=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_PATH ]]; then
        true
    fi
    
    
    ######################################################


local _PATH=${_PATH:-.}

if [[ ! -e "$_PATH" ]]; then
    echo "Error: Path [$_PATH] does not exist."
    return 1
fi

if [[ ! -r "$_PATH" ]]; then
    echo "Error: Path [$_PATH] is not readable by user '$USER'."
    return 1
fi

# use stat if available
if hash stat &> /dev/null; then
    echo $(stat -c %U "$_PATH")

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use File::stat;
print getpwuid(stat("$_PATH")->uid), "\n"
EOF

# use python as last resort
else
    python -c "import os, pwd
print pwd.getpwuid(os.stat('$_PATH').st_uid).pw_name"
fi


}
function _-owner() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-owner -- ${BASH_FUNK_PREFIX:-}-owner

function -realpath() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... [PATH]

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _PATH
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... [PATH]"
                echo 
                echo "Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m "
                echo "      The path to normalize."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_PATH && ${#params[@]} > 0 ]]; then
            _PATH=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_PATH ]]; then
        true
    fi
    
    
    ######################################################


# use readlink if available
if hash readlink &> /dev/null; then
    readlink -m "${_PATH:-.}"

# use perl if available
elif hash perl &> /dev/null; then
    perl << EOF
use Cwd 'abs_path';
print abs_path('${_PATH:-.}'), "\n"
EOF

# use python as last resort
else
    python -c "import os
print os.path.realpath('${_PATH:-.}')"
fi


}
function _-realpath() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-realpath -- ${BASH_FUNK_PREFIX:-}-realpath

function -sudo-append() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... FILE_PATH CONTENT

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _FILE_PATH _CONTENT
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... FILE_PATH CONTENT"
                echo 
                echo "Creates a file with the given content."
                echo 
                echo "Requirements:"
                echo "  + Sudo 'tee --append' is required."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mFILE_PATH\033[22m (required)"
                echo "      The path to the file to write."
                echo -e "  \033[1mCONTENT\033[22m (required)"
                echo "      The content to append to the file."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \033[1m$fn /tmp/testfile.cfg 'foo=bar'\033[22m"
                echo -e "Appending to \[/tmp/testfile.cfg\]..."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo -e "$ \033[1m$fn /tmp/testfile.cfg 'foo=bar'\033[22m"
                stdout=$($fn /tmp/testfile.cfg 'foo=bar'); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^Appending to \[/tmp/testfile.cfg\]...$"
                if [[ ! "$stdout" =~ $regex ]]; then echo -e "--> [31mFAILED[0m - stdout [$stdout] does not match required pattern [Appending to \[/tmp/testfile.cfg\]...].$hint"; return 1; fi
                echo "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_FILE_PATH ]]; then
            _FILE_PATH=$param
            continue
        fi
        if [[ ! $_CONTENT ]]; then
            _CONTENT=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_FILE_PATH ]]; then
        true
    else
        echo "$fn: Error: Parameter FILE_PATH must be specified.$hint"; return 1
    fi
    if [[ $_CONTENT ]]; then
        true
    else
        echo "$fn: Error: Parameter CONTENT must be specified.$hint"; return 1
    fi
    
    if ! hash "sudo" &> /dev/null; then echo "$fn: Error: Required command 'sudo' not found on this system.$hint"; return 1; fi
    if ! sudo -l -- tee --append &> /dev/null; then echo "$fn: Error: User $USER misses required sudo permission for 'tee --append'$hint"; return 1; fi
    
    ######################################################

echo "Appending to [$_FILE_PATH]..."
echo "$_CONTENT" | sudo tee --append "$_FILE_PATH" > /dev/null

}
function _-sudo-append() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-sudo-append -- ${BASH_FUNK_PREFIX:-}-sudo-append

function -sudo-write() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... FILE_PATH OWNER CONTENT

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _FILE_PATH _OWNER _CONTENT
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... FILE_PATH OWNER CONTENT"
                echo 
                echo "Creates a file with the given content."
                echo 
                echo "Requirements:"
                echo "  + Sudo 'sh -c' is required."
                echo "  + Sudo 'sh chown' is required."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mFILE_PATH\033[22m (required)"
                echo "      The path to the file to write."
                echo -e "  \033[1mOWNER\033[22m (required)"
                echo "      The owner and group to set."
                echo -e "  \033[1mCONTENT\033[22m (required)"
                echo "      The content to write."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                echo "Examples:"
                echo -e "$ \033[1m$fn /tmp/testfile.cfg $USER:$USER 'foo=bar'\033[22m"
                echo -e "Writing \[/tmp/testfile.cfg\]..."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo -e "$ \033[1m$fn /tmp/testfile.cfg $USER:$USER 'foo=bar'\033[22m"
                stdout=$($fn /tmp/testfile.cfg $USER:$USER 'foo=bar'); rc=$?
                echo $stdout
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                regex="^Writing \[/tmp/testfile.cfg\]...$"
                if [[ ! "$stdout" =~ $regex ]]; then echo -e "--> [31mFAILED[0m - stdout [$stdout] does not match required pattern [Writing \[/tmp/testfile.cfg\]...].$hint"; return 1; fi
                echo "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_FILE_PATH ]]; then
            _FILE_PATH=$param
            continue
        fi
        if [[ ! $_OWNER ]]; then
            _OWNER=$param
            continue
        fi
        if [[ ! $_CONTENT ]]; then
            _CONTENT=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_FILE_PATH ]]; then
        true
    else
        echo "$fn: Error: Parameter FILE_PATH must be specified.$hint"; return 1
    fi
    if [[ $_OWNER ]]; then
        true
    else
        echo "$fn: Error: Parameter OWNER must be specified.$hint"; return 1
    fi
    if [[ $_CONTENT ]]; then
        true
    else
        echo "$fn: Error: Parameter CONTENT must be specified.$hint"; return 1
    fi
    
    if ! hash "sudo" &> /dev/null; then echo "$fn: Error: Required command 'sudo' not found on this system.$hint"; return 1; fi
    if ! sudo -l -- sh -c &> /dev/null; then echo "$fn: Error: User $USER misses required sudo permission for 'sh -c'$hint"; return 1; fi
    if ! hash "sudo" &> /dev/null; then echo "$fn: Error: Required command 'sudo' not found on this system.$hint"; return 1; fi
    if ! sudo -l -- sh chown &> /dev/null; then echo "$fn: Error: User $USER misses required sudo permission for 'sh chown'$hint"; return 1; fi
    
    ######################################################

echo "Writing [$_FILE_PATH]..."
sudo sh -c "echo '$_CONTENT' > $_FILE_PATH" && sudo chown $_OWNER "$_FILE_PATH"

}
function _-sudo-write() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-sudo-write -- ${BASH_FUNK_PREFIX:-}-sudo-write

function -test-filesystem() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]...

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]..."
                echo 
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    
    
    ######################################################

${BASH_FUNK_PREFIX:-}-abspath --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-count-words --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-du --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-extract --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-findfiles --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-ll --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-mkcd --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-modified --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-owner --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-realpath --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-sudo-append --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-sudo-write --selftest && echo || return 1
${BASH_FUNK_PREFIX:-}-up --selftest && echo || return 1
}
function _-test-filesystem() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        COMPREPLY=($(compgen -o default -- $currentWord))
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-test-filesystem -- ${BASH_FUNK_PREFIX:-}-test-filesystem

function -up() {

    [[ -p /dev/stdout ]] && local _in_pipe=1 || local _in_pipe=
    [ -t 1 ] && local _in_subshell= || local _in_subshell=1
    local fn=${FUNCNAME[0]}
    [[ $_in_pipe || $_in_subshell ]] && local hint= || local hint="

Usage: $fn [OPTION]... [LEVEL_OR_NAME]

Type '$fn --help' for more details."
    local arg optionWithValue params=() _help _selftest _LEVEL_OR_NAME
    for arg in "$@"; do
        case $arg in
    
            --help)
                echo "Usage: $fn [OPTION]... [LEVEL_OR_NAME]"
                echo 
                echo "Navigates the given levels up in the directory tree."
                echo 
                echo "Parameters:"
                echo -e "  \033[1mLEVEL_OR_NAME\033[22m "
                echo "      The level to navigate up in the directory structure. Numeric value or the name of the directory to go back to."
                echo 
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo 
                return 0
              ;;
    
            --selftest)
                echo "Testing function [$fn]..."
                echo -e "$ \033[1m$fn --help\033[22m"
                local regex stdout rc
                stdout=$($fn --help); rc=$?
                if [[ $rc != 0 ]]; then echo -e "--> [31mFAILED[0m - exit code [$rc] instead of expected [0].$hint"; return 1; fi
                echo -e "--> [32mOK[0m"
                echo "Testing function [$fn]...DONE"
                return 0
              ;;
    
    
    
            -*)
                echo "$fn: invalid option: '$arg'"
                echo Type \'$fn --help\' for usage.
                return 1
              ;;
    
            *)
                case $optionWithValue in
                    *)
                        params+=("$arg")
                esac
              ;;
        esac
    done
    unset arg optionWithValue
    
    for param in "${params[@]}"; do
        if [[ ! $_LEVEL_OR_NAME && ${#params[@]} > 0 ]]; then
            _LEVEL_OR_NAME=$param
            continue
        fi
        echo "$fn: Error: too many parameters: '$param'$hint"
        return 1
    done
    unset param params leftoverParams
    
    
    if [[ $_LEVEL_OR_NAME ]]; then
        true
    fi
    
    
    ######################################################

if [[ ! $_LEVEL_OR_NAME ]]; then 
    cd ..
    return 0
fi

if [[ $_LEVEL_OR_NAME =~ ^[0-9]+$ ]]; then
    local cdArgs
    for (( i = 0; i < _LEVEL_OR_NAME; i++ )); do
        cdArgs="../$cdArgs"
    done
    cd $cdArgs
else
    local path=$(pwd)
    cd "${path%${_LEVEL_OR_NAME}*}${_LEVEL_OR_NAME}"
fi

}
function _-up() {
    local currentWord=${COMP_WORDS[COMP_CWORD]}
    if [[ ${currentWord} == -* ]]; then
        local options=" --help --selftest "
        for o in ${COMP_WORDS[@]}; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $currentWord))
    else
        local path="$(pwd)"; COMPREPLY=( $(IFS=$'\n' compgen -o default -W "$( echo -e "${path////\n}" | sed 's/^/\x27/; s/$/\x27/' )" -- "$currentWord") )
    fi
}
complete -F _${BASH_FUNK_PREFIX:-}-up -- ${BASH_FUNK_PREFIX:-}-up

function -help-filesystem() {

    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-abspath [PATH]\033[0m  -  Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-count-words FILE WORD1 [WORD]...\033[0m  -  Counts the number of occurences of the word(s) in the given file."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-du [PATH]...\033[0m  -  Prints disk usage information."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-extract FILE\033[0m  -  Extracts the given archive using the compatible extractor."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-findfiles [START_PATH] SEARCH_STRING\033[0m  -  Recursively finds all files containing the given string and displays their path."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-ll [PATH]...\033[0m  -  Alternative version of 'ls -lt' hat prints directories and symbolic links to directories before files."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-mkcd PATH\033[0m  -  Creates a directory and changes into it."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-modified [PATH]\033[0m  -  Prints the modification timestamp of the given file or directory."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-owner [PATH]\033[0m  -  Prints the owner of the given file or directory."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-realpath [PATH]\033[0m  -  Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-sudo-append FILE_PATH CONTENT\033[0m  -  Creates a file with the given content."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-sudo-write FILE_PATH OWNER CONTENT\033[0m  -  Creates a file with the given content."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-test-filesystem\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."
    echo -e "\033[1m${BASH_FUNK_PREFIX:-}-up [LEVEL_OR_NAME]\033[0m  -  Navigates the given levels up in the directory tree."

}


alias ll="${BASH_FUNK_PREFIX:-}-ll"

