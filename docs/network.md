# Bash-Funk "network" module

[//]: # (THIS FILE IS GENERATED BY BASH-FUNK GENERATOR)

The following commands are available when this module is loaded:

1. [-block-port](#-block-port)
1. [-is-port-open](#-is-port-open)
1. [-my-ips](#-my-ips)
1. [-run-echo-server](#-run-echo-server)
1. [-set-proxy](#-set-proxy)
1. [-ssh-agent-add-key](#-ssh-agent-add-key)
1. [-ssh-gen-keypair](#-ssh-gen-keypair)
1. [-ssh-reconnect](#-ssh-reconnect)
1. [-ssh-trust-host](#-ssh-trust-host)
1. [-test-network](#-test-network)


## <a name="license"></a>License

Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.


## <a name="-block-port"></a>-block-port

```
Usage: -block-port [OPTION]... [BIND_ADDRESS] PORT

Binds to the given port and thus block other programs from binding to it.

Parameters:
  BIND_ADDRESS (default: '0.0.0.0')
      The local bind address. E.g. 127.0.0.1.
  PORT (required, integer: 0-65535)
      Number of the port to occupy.

Options:
-d, --duration SECONDS (integer: ?-?)
        Duration in seconds to block the port.
    -----------------------------
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
    --
        Terminates the option list.

Examples:
$ -block-port --duration 1  12345
Binding to 0.0.0.0:12345...
Press [CTRL]+[C] to abort.
$ -block-port -d 1  127.0.0.1  12345
Binding to 127.0.0.1:12345...
Press [CTRL]+[C] to abort.
```

*Implementation:*
```bash
echo "Binding to $_BIND_ADDRESS:$_PORT..."

[[ $_duration ]] && local timeout="Timeout => $_duration," || local timeout="";

perl << EOF
    use IO::Socket;
    \$server = IO::Socket::INET->new(
        LocalAddr => '$_BIND_ADDRESS',
        LocalPort => $_PORT,
        Type => SOCK_STREAM,
        ReuseAddr => 1,
        $timeout
        Listen => 10
    ) or die "Couldn't bind to $_BIND_ADDRESS:$_PORT: \$@\n";
    print("Press [CTRL]+[C] to abort.\n");
    while (\$client = \$server->accept()) { }
    close(\$server);
EOF
```


## <a name="-is-port-open"></a>-is-port-open

```
Usage: -is-port-open [OPTION]... HOSTNAME PORT [CONNECT_TIMEOUT_IN_SECONDS]

Checks if a TCP connection can be established to the given port.

Parameters:
  HOSTNAME (required)
      Target hostname.
  PORT (required, integer: 0-65535)
      Target TCP port.
  CONNECT_TIMEOUT_IN_SECONDS (default: '5', integer: ?-?)
      Number of seconds to try to connect to the given port. Default is 5 seconds.

Options:
-v, --verbose 
        Prints additional information during command execution.
    -----------------------------
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
    --
        Terminates the option list.

Examples:
$ -is-port-open localhost 12345 1

$ -is-port-open -v localhost 12345 1
localhost:12345 is not reachable.
```

*Implementation:*
```bash
if hash nc &>/dev/null; then
    if nc -vz -w $_CONNECT_TIMEOUT_IN_SECONDS $_HOSTNAME $_PORT; then
        portStatus=open
    else
        portStatus=
    fi
else
    local portStatus=$(perl << EOF
        use IO::Socket;
        my \$socket=IO::Socket::INET->new(
            PeerAddr => "$_HOSTNAME",
            PeerPort => $_PORT,
            Timeout => $_CONNECT_TIMEOUT_IN_SECONDS
        );

        if (defined \$socket) {
            sleep 1;
            (defined \$socket->connected ? print("open") : q{});
        }
EOF
    )
fi

if [[ $portStatus == "open" ]]; then
    [[ $_verbose ]] && echo "$_HOSTNAME:$_PORT is open." || true
    return 0
else
    [[ $_verbose ]] && echo "$_HOSTNAME:$_PORT is not reachable." || true
    return 1
fi
```


## <a name="-my-ips"></a>-my-ips

```
Usage: -my-ips [OPTION]...

Prints the IP v4 addresses of this host excluding 127.0.0.1.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
    --
        Terminates the option list.
```

*Implementation:*
```bash
ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'
```


## <a name="-run-echo-server"></a>-run-echo-server

```
Usage: -run-echo-server [OPTION]... [BIND_ADDRESS] PORT

Runs a simple single-connection TCP echo server.

Requirements:
  + Command 'python' must be available.

Parameters:
  BIND_ADDRESS (default: '0.0.0.0')
      The local bind address. E.g. 127.0.0.1.
  PORT (required, integer: 0-65535)
      Number of the TCP port to be used.

Options:
    --disconnect_when string 
        String that can be send to the server to disconnect the current connection.
    --stop_when string 
        String that can be send to the server to shut it down.
    -----------------------------
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
    --
        Terminates the option list.
```

*Implementation:*
```bash

if [[ ! $_stop_when ]]; then
    local _stop_when=stop
fi

if [[ ! $_disconnect_when ]]; then
    local _disconnect_when=quit
fi

python -c "
import socket, sys

def run():
    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind(('$_BIND_ADDRESS', $_PORT))
    srv.listen(0)

    print('Running TCP echo server on $_BIND_ADDRESS:$_PORT...')

    while 1:
        conn, src_addr = srv.accept()
        print('[CONNECT] %s' % src_addr)

        while 1:
            data, src_addr = conn.recvfrom(256)

            if not data:
                continue

            if data == '$_stop_when\r\n':
                print('[SHUTDOWN] %s' % src_addr)
                sys.exit(0)

            if data == '$_disconnect_when\r\n':
                print('[DISCONNECT] %s' % src_addr)
                conn.shutdown(1)
                conn.close()
                break

            conn.sendall(data)
            sys.stdout.write(data)
            sys.stdout.flush()

try:
    run()
except KeyboardInterrupt:
    pass
"
```


## <a name="-set-proxy"></a>-set-proxy

```
Usage: -set-proxy [OPTION]... PROXY_URL [NO_PROXY]

Sets the proxy environment variables.

Parameters:
  PROXY_URL (required)
      The proxy URL to set.
  NO_PROXY 
      Proxy exclusions.

Options:
-v, --verbose 
        Prints additional information during command execution.
    -----------------------------
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
    --
        Terminates the option list.
```

*Implementation:*
```bash
for varname in all_proxy ALL_PROXY ftp_proxy FTP_PROXY http_proxy HTTP_PROXY https_proxy HTTPS_PROXY; do
    [[ $_verbose ]] && echo "Setting $varname=$_PROXY_URL"
    export $varname=$_PROXY_URL
done

# exclude local IPs from proxy
if hash ifconfig &>/dev/null; then
    local my_ips=$(ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*')
else
    local my_ips=::1,127.0.0.1
fi
no_proxy=localhost,${my_ips//$'\n'/,}

# exclude metadata IP if AWS EC2 server
if [[ -f /sys/hypervisor/uuid && $(head -c 3 /sys/hypervisor/uuid) == "ec2" ]]; then
    no_proxy="$no_proxy,169.254.169.254"
fi

export no_proxy="$no_proxy,$_NO_PROXY"
[[ $_verbose ]] && echo "Setting no_proxy=$no_proxy"
[[ $_verbose ]] && echo "Setting NO_PROXY="
export NO_PROXY=$no_proxy
```


## <a name="-ssh-agent-add-key"></a>-ssh-agent-add-key

```
Usage: -ssh-agent-add-key [OPTION]... KEY_FILE PASSWORD

Adds the private key to the ssh-agent.

Requirements:
  + Command 'ssh-add' must be available.
  + Command 'ssh-agent' must be available.
  + Command 'expect' must be available.

Parameters:
  KEY_FILE (required, file)
      Path to the key file.
  PASSWORD (required)
      Password to open the key file.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
    --
        Terminates the option list.
```

*Implementation:*
```bash
eval $(ssh-agent)

expect << EOF
  spawn ssh-add $_KEY_FILE
  expect "Enter passphrase"
  send "$_PASSWORD\r"
  expect eof
EOF
```


## <a name="-ssh-gen-keypair"></a>-ssh-gen-keypair

```
Usage: -ssh-gen-keypair [OPTION]... FILENAME

Creates an private/public SSH keypair.

Requirements:
  + Command 'ssh-keygen' must be available.

Parameters:
  FILENAME (required, file)
      Private key filename.

Options:
-C, --comment COMMENT 
        Comment.
    --keysize SIZE (integer: 1-?)
        Number of bits of the private key. Default is 4096.
-p, --password PASSWORD 
        Password to protect the private key file.
    -----------------------------
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
    --
        Terminates the option list.
```

*Implementation:*
```bash
local opts

# if password is specified and new OpenSSH key format is supported by ssh-keygen, then enable it
if [[ ${_password:-} ]] && ssh-keygen --help 2>&1 | grep -q -- " -o "; then
    opts=-o -a 500
fi

ssh-keygen -t rsa -f $_FILENAME -N "${_password:-}" -b ${_keysize:-4096} -C "${_comment:-}" $opts
```


## <a name="-ssh-reconnect"></a>-ssh-reconnect

```
Usage: -ssh-reconnect [OPTION]... [GREP_PATTERN]...

Dialog that displays the last 10 issued SSH commands to execute one of them.

Parameters:
  GREP_PATTERN 
      Only show SSH commands that contain the given patterns.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
    --
        Terminates the option list.
```

*Implementation:*
```bash
local filter=
if [[ ${_GREP_PATTERN:-} ]]; then
    local p
    for p in "${_GREP_PATTERN[@]}"; do
        filter="$filter | grep \"$p\""
    done
fi
ssh_hist="$(eval -- "-tail-reverse "$HISTFILE" -u | grep \"^ssh \" $filter | head -10")"
ssh_hist="${ssh_hist//\"/\\\"}"
local ssh_cmd
echo Please select the SSH command to execute and press [ENTER]. Press [ESC] or [CTRL]+[C] to abort:
echo
eval -- ${BASH_FUNK_PREFIX:-}choose --assign ssh_cmd "\"${ssh_hist//$'\n'/\" \"}\"" || return 1
echo
echo "Press Enter when ready. [CTRL]+[C] to abort."
read -e -p "$ " -i "$ssh_cmd" ssh_cmd
echo -e "Executing command [\033[35m$ssh_cmd\033[0m]..."
history -s -- "$ssh_cmd"
eval -- $ssh_cmd
```


## <a name="-ssh-trust-host"></a>-ssh-trust-host

```
Usage: -ssh-trust-host [OPTION]... HOSTNAME [PORT]

Adds the public key of the given host to the ~/.ssh/known_hosts file.

Requirements:
  + Command 'ssh-keyscan' must be available.

Parameters:
  HOSTNAME (required)
      Remote SSH Hostname.
  PORT (default: '22', integer: 0-65535)
      Remote SSH port.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
    --
        Terminates the option list.
```

*Implementation:*
```bash
touch ~/.ssh/known_hosts
ssh-keyscan -t rsa,dsa -p $_PORT $_HOSTNAME 2>/dev/null | sort -u - ~/.ssh/known_hosts > ~/.ssh/known_hosts.tmp
mv ~/.ssh/known_hosts.tmp ~/.ssh/known_hosts
```


## <a name="-test-network"></a>-test-network

```
Usage: -test-network [OPTION]...

Performs a selftest of all functions of this module by executing each function with option '--selftest'.

Options:
    --help 
        Prints this help.
    --selftest 
        Performs a self-test.
    --
        Terminates the option list.
```

*Implementation:*
```bash
-block-port --selftest && echo || return 1
-is-port-open --selftest && echo || return 1
-my-ips --selftest && echo || return 1
-run-echo-server --selftest && echo || return 1
-set-proxy --selftest && echo || return 1
-ssh-agent-add-key --selftest && echo || return 1
-ssh-gen-keypair --selftest && echo || return 1
-ssh-reconnect --selftest && echo || return 1
-ssh-trust-host --selftest && echo || return 1
```
